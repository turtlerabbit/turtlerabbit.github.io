---
title: Dynamic Data - Sample
date: '2021-01-10 03'
tag: DynamicData, sample, IEnumerable, ObservableChangeSet, IChangeSet, ISourceCache, IConnectableObservable, IObservableCache
---
#
### @Service layer
#
1. IEnumerable`<`T`>` 
    - public static class Enumerable  
    - IEnumerable`<`int`>` Enumerable.Range(int start, int count)  
    - IEnumerable`<`TResult`>` Select`<`TSource, TResult`>`  
      (this IEnumerable`<`TSource`>` source, Func`<`TSource, TResult`>` selector); 
```js
public IEnumerable<Trade> Generate(int numberToGenerate)
{
    return Enumerable
        .Range(1, numberToGenerate)
        .Select(_ => NewTrade())
        .ToArray();

    Trade NewTrade()
    {
        ...
        return new Trade(id, customer, price);
    }
}
```
#
2. ObservableChangeSet.Create`<`TObject,TKey`>`();
```js
// Creating Observable Change Sets
private IObservable<IChangeSet<Trade, long>> GenerateTradesAndMaintainCache()
{
    return ObservableChangeSet.Create<Trade, long>(cache =>
    {
        cache.AddOrUpdate(this.tradeGenerator.Generate(5));

        return cleanUp;
    }, trade => trade.Id);
}
```
#
3. IObservable`<`T`>`.Publish();  
#
`기본 시퀀스에 대한 단일 구독을 공유하는`(shares a single subscription) 연결 가능한 관찰 가능 시퀀스(`IConnectableObservable<IChangeSet<Trade, int>>`)를 반환한다.  
```js
IConnectableObservable<IChangeSet<Trade, int>> 
    IObservable<IChangeSet<Trade, int>>.Publish();
```
publish() 연산자는 보통의 Observable을 ConnectableObservable로 변환해 준다. 
ConnectableObservable은 Subscriber가 있어도 connect()를 호출하기 전까지는 아이템을 방출하지 않는다. connect()를 호출하고 나서야 아이템을 방출하기 시작한다.
#
4. IConnectableObservable`<`T`>`.AsObservableCache();  
   - Converts the source **to a readonly observable cache.**  
   - Automatically refresh downstream operators when properties change.  
```js
IObservableCache<Trade, int> 
    IConnectableObservable<IChangeSet<Trade, int>>.AsObservableCache();
```
`IObservableCache` : 메모리 데이타를 관찰하고 쿼리하기 위한 캐쉬이다.  
```js
 public interface IObservableCache<TObject, TKey>
    : IConnectableCache<TObject, TKey>, IDisposable where TKey : notnull
```
#
### @ViewModel layer
#
```js
public class LiveTrade : IDisposable
{
    private readonly IDisposable cleanUp;
    private readonly ReadOnlyObservableCollection<TradeProxy> data;
    public ReadOnlyObservableCollection<TradeProxy> Data => this.data;

    public LiveTrade(TradeService tradeService)
    {
        var loader = tradeService
            .All
            .Connect()
            .Transform(trade => new TradeProxy(trade))
            .ObserveOn(Scheduler.CurrentThread)
            .Bind(out this.data)
            .DisposeMany()
            .Subscribe();

        this.cleanUp = new CompositeDisposable(loader);
    }

    public void Dispose()
    {
        this.cleanUp.Dispose();
    }
}
```
#
5. IConnectableCache`<`Trade, int`>`.Connect() :  
    - Returns a filtered stream of cache changes preceded with the initial filtered state.  
    - return value : An observable that emits the change set  
```js
 IObservable<IChangeSet<Trede, int>> IConnectableCache<Trade, int>.Connect();
```
#
6. IObservable`<`IChangeSet`<`Trede, int`>>`.Transform() :  
    - Projects each update item to a new form using the specified transform function.  
    - return value : A transformd update collection.  
#
7. IObservable`<`IChangeSet`<`TradeProxy, int`>>`.ObserveOn() :  
    - Wraps the source sequence **in order to run its observer callbacks on the specified scheduler**.  
    - return value : The source sequence whose observations happen on the specified scheduler.  
#
8. IObservable`<`IChangeSet`<`TradeProxy, int`>>`.Bind() :  
    - Binds the results **to the specified readonly observable collection** using the default update algorithm.  
    - return value : An observable which will emit change sets. 
#
9. ReadOnlyObservableCollection`<`TradeProxy`>` :  
    - Represents a read-only ObservableCollection`<`T`>`. 
#
10. IObservable`<`IChangeSet`<`TradeProxy, int`>>`.DisposeMany() :  
    - Disposes each item when no longer required.  
    - Individual items are disposed when removed or replaced.  
    - All items are disposed when the stream is disposed.  
    - return value : A continuation of the original stream.  
#
11. IDisposable IObservable`<`IChangeSet`<`TradeProxy, int`>>`.Subscribe() :  
    - Subscribes to the observable sequence without specifying any handlers.  
    - This method can be used to evaluate the observable sequence for its side-effects only.  
    - return value : IDisposable object used **to unsubscribe from the observable sequence**.  
#
## 요약
```js
// IEnumerable<T>
IEnumerable<Trade> Generate(int numberToGenerate)


// Creating Observable Change Sets : IObservable<IChangeSet<TObject,TKey>>
IObservable<IChangeSet<Trade,long>> 
    ObservableChangeSet.Create<Trade, long>(ISourceCache<Trade, long> =>
    {
        ISourceCache<Trade, long>.AddOrUpdate(Generate());
    }, trade = > trade.Id);


// 기본 시퀀스에 대한 단일 구독을 공유하기 위해
IConnectableObservable<IChangeSet<Trade, long>> 
    IObservable<IChangeSet<Trade, long>>.Publish();


// 읽기전용으로 파생 컬렉션을 만들어 노출하기 위해
IObservableCache<Trade, long> 
    IConnectableObservable<IChangeSet<Trade, long>>.AsObservableCache();


// IObservableCache는 IConnectableCache를 상속받은 모습이다.
public interface IObservableCache<TObject, TKey>
    : IConnectableCache<TObject, TKey>, IDisposable where TKey : notnull


// 읽기전용으로 노출된 외부에서 Connect()함으로써 
// change set을 방출하는 observable을 반환한다.
IObservable<IChangeSet<Trede, long>> 
    IConnectableCache<Trade, long>.Connect();
```
#
[source](https://github.com/ledpink/DynamicData/tree/main/TradeConsoleApp)
