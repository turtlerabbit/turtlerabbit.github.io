---
title: Dynamic Data - Consuming Observable Change Sets
date: '2021-01-10 02'
tag: DynamicData, SourceCache, SourceList, observable-change-sets, ToObservableChangeSet, ObservableChangeSet 
---

이제 observable cache or observable list를 만들 수 있다.  
다음은 수행 할 수있는 다양한 범위를 설명하는 몇 가지 빠른 실행 예제다. 
#
### Create a Derived List or Cache
이 예에서는 observable change set에서 파생 컬렉션을 만드는 방법을 보여준다.
```js
// Given a SourceList
var myList = new SourceList<People>();

var oldPeople = myList
      .Connect()
      .Filter(person => person.Age > 65)  // 필터에 적용된 항목만을 포함하는
      .AsObservableList();  // 새로운 observable list를 만든다.
```
이 패턴은 기존 컬렉션을 수정 한 다음 수정 된 컬렉션을 소비자에게 노출하려는 
경우 매우 유용하다.
#
The same pattern can be used with **SourceCache** by using **.AsObservableCache()** to create derived caches.
#
As an alternative to **.Bind(out collection)** you can use **.BindToObservableList(out observableList)** for both SourceList & SourceCache.  
컬렉션이 새로 고침 알림을 지원하지 않기 때문에 **.AutoRefresh()**를 사용하는 소스에서 파생 된 read-only lists를 가져 오는 데 유용하다.

#
### Observing Properties of Objects in a Collection
컬렉션이 INotifyPropertyChanged를 구현하는 개체로 구성된 경우 다음 연산자를 사용할 수 있다.
```js
// WhenValueChanged 연산자는 
// 지정된 속성 값이 변경된 경우 관찰 가능한 값을 반환한다.

var ageChanged = peopleDataSource
      .Connect()
      .WhenValueChanged(p => p.Age)

#

// WhenPropertyChanged 연산자는 
// 지정된 속성이 변경된 경우 부모 개체뿐 아니라 
// 지정된 속성의 값으로 구성된 관찰 가능 항목을 반환한다.

var ageChanged = peopleDataSource
      .Connect()
      .WhenPropertyChanged(p => p.Age)

#

// WhenAnyPropertyChanged 연산자는 
// 속성이 변경된 경우 개체의 관찰 가능 개체를 반환한다.

var personChanged = peopleDataSource
      .Connect()
      .WhenAnyPropertyChanged()
```
#
### Observing item changes
바인딩은 동적 데이터의 매우 작은 부분이다.  
위의 알림 속성 변경 오버로드는 바인딩시의 예일뿐이다.  
자식 Observable이 있는 도메인 개체가 있는 경우 컬렉션 변경에 따라 
항목을 구독 및 구독 취소하는 **MergeMany()**를 사용할 수 있다.
```js
// MergeMany 연산자

var myoperation = somedynamicdatasource
      .Connect()
      .MergeMany(trade => trade.SomeObservable());
        // 컬렉션이 변경되면 SomeObservable이 연결 및 연결 해제된다.

```
### Filtering
```js
// Filter the observable change set by using the Filter operator

var myPeople = new SourceList<People>();
var myPeopleObservable = myPeople.Connect();

var myFilteredObservable = myPeopleObservable.Filter(person => person.Age > 50);

#

IObservable<Func<Person,bool>> observablePredicate=...;
var myFilteredObservable = myPeopleObservable.Filter(observablePredicate);
```
#
### Sorting
```js
// Sort the observable change set by using the Sort operator

var myPeople = new SourceList<People>();
var myPeopleObservable = myPeople.Connect();

var mySortedObservable = myPeopleObservable
      .Sort(SortExpressionComparer
      .Ascending(p => p.Age); 

#

IObservable<IComparer<Person>> observableComparer=...;
var mySortedObservable = myPeopleObservable.Sort(observableComparer);
```
#
### Grouping
```js
// GroupOn 연산자는 group selector에 따라 지정된 그룹을 사전 캐시한다.
var myOperation = personChangeSet.GroupOn(person => person.Status)
```
#
### Transformation
```js
// The Transform operator allows you to map objects from 
// the observable change set to another object

var myPeople = new SourceList<People>();
var myPeopleObservable = myPeople.Connect();

var myTransformedObservable = 
        myPeopleObservable.Transform(person => new PersonProxy(person));

#

// The TransformToTree operator allows you to create a fully formed reactive tree 
// (only available for observable cache)

var myPeople = new SourceCache<Person, string>(p => p.Name);
var myTransformedObservable = myPeople
        .Connect()
        .TransformToTree(person => person.BossId);
```
#
### Aggregation
```js
// The Count, Max, Min, Avg, and StdDev operators allow you 
// to perform aggregate functions on observable change sets

var myPeople = new SourceList<People>();
var myPeopleObservable = myPeople.Connect();

var countObservable = 	 myPeopleObservable.Count();
var maxObservable = 	 myPeopleObservable.Max(p => p.Age);
var minObservable = 	 myPeopleObservable.Min(p => p.Age);
var stdDevObservable =   myPeopleObservable.StdDev(p => p.Age);
var avgObservable = 	 myPeopleObservable.Avg(p => p.Age);
```
#
### Logical Operators
```js
// The And, Or, Xor and Except operators allow you 
// to perform logical operations on observable change sets

var peopleA = new SourceCache<Person,string>(p => p.Name);
var peopleB = new SourceCache<Person,string>(p => p.Name);

var observableA = peopleA.Connect();
var observableB = peopleB.Connect();

var inBoth = observableA.And(observableB);
var inEither= observableA.Or(observableB);
var inOnlyOne= observableA.Xor(observableB);
var inAandNotinB = observableA.Except(observableB);

#

// A recent and very powerful feature is dynamic logical operators.

var list1 = new SourceList<int>();
var list2 = new SourceList<int>();
var list3  = new SourceList<int>();
	
var combined = new SourceList<ISourceList<int>>();

//child lists can be added or removed any time
combined.Add(list1);
combined.Add(list2);
combined.Add(list3);

//The operators look after themselves 
var inAll = combined.And();
var inAny = combined.Or();
var inOnlyOne= combined.Xor();
var inFirstAndNotAnyOther = combined.Except();
```
#
### Disposal
```js
// The DisposeMany operator는 
// observable stream에서 제거 될 때 개체가 삭제되도록 한다.

var myPeople = new SourceList<People>();
var myPeopleObservable = myPeople.Connect();

var myTransformedObservable = myPeopleObservable
      .Transform(person => new DisposablePersonProxy(person))
      .DisposeMany(); // 보통 transform function이 일회용 개체를 만들 때 사용된다.
```
#
### Distinct Values
```js
// DistinctValues 연산자는 기본 컬렉션에서 고유 한 값을 선택한다.

var myPeople = new SourceList<People>();
var myPeopleObservable = myPeople.Connect();

var myDistinctObservable = 
      myPeopleObservable.DistinctValues(person => person.Age);
```
#
### Virtualisation
```js
// index 및 segment size별로 제한 할 데이터 시각화

IObservable<IVirtualRequest> request; //request stream
var virtualisedStream = someDynamicDataSource.Virtualise(request)

#

// Visualise data to restrict by index and page size

IObservable<IPageRequest> request; //request stream
var pagedStream = someDynamicDataSource.Page(request)

#
// 위 중 하나에서 요청 스트림이 변경되면 결과가 재평가된다.

var topStream = someDynamicDataSource.Top(10) // 'n'항목과 일치하는 항목 반환
```