---
title: Dynamic Data - Grouping
date: '2021-01-12 09'
tag: DynamicData, Grouping, GroupWithImmutableState(), GroupOn(), ChangeKey()
---
#
### 1. Group And Monitor PropertyChanges
* 속성의 첫 글자를 기준으로 그룹화하고 속성 변경시 그룹화 업데이트
```js
private readonly IDisposable cleanUp;
public IObservableList<SpeciesGroup> SpeciesByLetter { get; }

public GroupAndMonitorPropertyChanges(ISourceList<Species> sourceList)
{
    var shared = sourceList.Connect().Publish();

    // fired when the name changes on any item in the source collection
    var nameChanged = shared.WhenValueChanged(species => species.Name);

    // 첫 글자로 그룹화 하고
    // 선택적으로 the nameChanged observable (as a unit)을 전달하여 
    // 그룹화가 그룹화를 다시 적용하도록 지시한다.
    SpeciesByLetter = shared
        .GroupWithImmutableState(x => x.Name[0], nameChanged.Select(_ => Unit.Default))
        .Transform(grouping => new SpeciesGroup(grouping.Key, grouping.Items))
        .AsObservableList();

    // 여기서 species의 이름이 변경되면 파생 목록이 자체적으로 유지된다.

    // Nothing happens until a Published source is connect
    var connected = shared.Connect();

    this.cleanUp = new CompositeDisposable(sourceList, SpeciesByLetter, connected);
}

#

using (var sourceList = new SourceList<Species>())
using (var sut = new GroupAndMonitorPropertyChanges(sourceList))
{
// populate with initial data
var initialData = new[]
{
    new Species("Ant"),
    new Species("Ape"),
    new Species("Bear"),
    new Species("Boar"),
    new Species("Cougar")
};
sourceList.AddRange(initialData);

// Check all data has loaded
var items = sut.SpeciesByLetter.Items.SelectMany(g => g.Items);
foreach (var item in items)
{
    Console.WriteLine(item.Name);  // should all be Equivalent to initialData
}

var manualGrouping = sut.SpeciesByLetter.Items;
foreach (var item in manualGrouping)
{
    Console.WriteLine(item.Key);  // should be Equivalent to sourceList
}

Console.WriteLine(sut.SpeciesByLetter.Count);  // 3

// 데이터의 첫 글자를 변경하면 그룹이 변경된다.
initialData[0].Name = "햚t";  // change the first letter
Console.WriteLine(sut.SpeciesByLetter.Count);  // 4

// assert everything
var assertEverything = sut.SpeciesByLetter.Items;
foreach (var item in assertEverything)
{
    Console.WriteLine(item.Key);  // should be Equivalent to sourceList
}
```
#
```js
DynamicData.ObservableListEx.GroupWithImmutableState();
// group selector factory에서 반환 한 값에 따라 소스를 그룹화한다.
// 각 업데이트는 변경 불가능한 그룹화를 생성한다.

public static IObservable<IChangeSet<IGrouping<TObject, TGroupKey>>> 
    GroupWithImmutableState<TObject, TGroupKey>(
          this IObservable<IChangeSet<TObject>> source, 
          Func<TObject, TGroupKey> groupSelectorKey, 
          IObservable<Unit>? regrouper = null) where TGroupKey : notnull;
```
#
### 2. Xamarin Forms Grouping
* Xamarin Forms를 사용한 맞춤형 그룹화
```js
private readonly IDisposable cleanUp;
private Func<Animal, bool> filter = a => true;
public Func<Animal, bool> Filter
{
    get => this.filter;
    set => SetAndRaise(ref this.filter, value);
}
public ReadOnlyObservableCollection<AnimalGroup> FamilyGroups { get; }

public XamarinFormsGrouping(IObservableList<Animal> source, 
                            ISchedulerProvider schedulerProvider)
{
    /* Xamarin forms is a bit dumb 
      * and cannot handle nested observable collections. 
      * To cirumvent this limitation, 
      * create a specialist observable collection with headers 
      * and use dynamic data to manage it */

    // create an observable predicate
    var observablePredicate = this
        .WhenValueChanged(@this => @this.Filter)
        .ObserveOn(schedulerProvider.Background);

    this.cleanUp = source
        .Connect()
        .Filter(observablePredicate)  // Apply filter dynamically                
        .GroupOn(arg => arg.Family)  // create a dynamic group
        .Transform(grouping => new AnimalGroup(grouping, schedulerProvider)) 
                       //transform into a specialised observable collection
        .Sort(SortExpressionComparer<AnimalGroup>.Ascending(a => a.Family))
        .ObserveOn(schedulerProvider.MainThread)
        .Bind(out var animals)
        .DisposeMany() //use DisposeMany() because the grouping is disposable
        .Subscribe();

    FamilyGroups = animals;
}

#

var items = new[]
{
    new Animal("Holly", "Cat", AnimalFamily.Mammal),
    new Animal("Rover", "Dog", AnimalFamily.Mammal),
    new Animal("Rex", "Dog", AnimalFamily.Mammal),
    new Animal("Whiskers", "Cat", AnimalFamily.Mammal),
    new Animal("Nemo", "Fish", AnimalFamily.Fish),
    new Animal("Moby Dick", "Whale", AnimalFamily.Mammal),
    new Animal("Fred", "Frog", AnimalFamily.Amphibian),
    new Animal("Isaac", "Next", AnimalFamily.Amphibian),
    new Animal("Sam", "Snake", AnimalFamily.Reptile),
    new Animal("Sharon", "Red Backed Shrike", AnimalFamily.Bird),
};

var schedulerProvider = new TestSchedulerProvider();

using (var sourceList = new SourceList<Animal>())
using (var sut = new XamarinFormsGrouping(sourceList, schedulerProvider))
{
    // populate with initial data
    sourceList.AddRange(items);

    Console.WriteLine(sut.FamilyGroups.Count);  // 5
    Console.WriteLine(
      sut.FamilyGroups.Single(group => group.Family == AnimalFamily.Mammal).Count); // 5
    Console.WriteLine(
      sut.FamilyGroups.Single(group => group.Family == AnimalFamily.Fish).Count);  // 1

    // apply a filter
    sut.Filter = a => a.Type == "Dog" || a.Type == "Fish";

    Console.WriteLine(sut.FamilyGroups.Count);  // 2
    Console.WriteLine(
      sut.FamilyGroups.Single(group => group.Family == AnimalFamily.Mammal).Count); // 5
    Console.WriteLine(
      sut.FamilyGroups.Single(group => group.Family == AnimalFamily.Fish).Count);  // 1

    // clear list and all groupings are gone
    sourceList.Clear();
    Console.WriteLine(sut.FamilyGroups.Count);  // 0
}
```
#
```js
DynamicData.ObservableListEx.GroupOn();
// Groups the source on the value returned by group selector factory.
// The groupings contains an inner observable list.

public static IObservable<IChangeSet<IGroup<TObject, TGroup>>> 
    GroupOn<TObject, TGroup>(this IObservable<IChangeSet<TObject>> source, 
          Func<TObject, TGroup> groupSelector, IObservable<Unit>? regrouper = null) 
              where TGroup : notnull;
```
#
### 3. Custom Total Rows
* 사용자 지정 집계에 그룹화를 사용할 수있는 방법 설명
* 이 기술은 동적 누적 합계로 그리드 데이터를 만드는 데 사용할 수 있다.   
[In production systems I also include the ability to have total row expanders - perhaps an example could follow another time]

```js
private readonly IDisposable cleanUp;
public IObservableCache<TradeProxy, AggregationKey> AggregatedData { get; }

public CustomTotalRows(IObservableCache<Trade, int> source)
{
    // 1. create a trade proxy which enriches the trade with an aggregation id.
    var ticker = source
        .Connect()
        .ChangeKey(proxy => 
            new AggregationKey(AggregationType.Item, proxy.Id.ToString()))
        .Transform((trade, key) => new TradeProxy(trade, key));

    // 2. create grouping based on each ticker
    var tickerTotals = source
        .Connect()
        .GroupWithImmutableState(trade => 
            new AggregationKey(AggregationType.SubTotal, trade.Ticker))
        .Transform(grouping => new TradeProxy(grouping.Items.ToArray(), grouping.Key));

    // 3. create grouping of 1 so we can create grand total row
    var overallTotal = source
        .Connect()
        .GroupWithImmutableState(trade => 
            new AggregationKey(AggregationType.GrandTotal, "All"))
        .Transform(grouping => new TradeProxy(grouping.Items.ToArray(), grouping.Key));

    // 4. join all togather so results are in a single cache
    AggregatedData = ticker
        .Or(overallTotal)
        .Or(tickerTotals)
        .AsObservableCache();

    this.cleanUp = AggregatedData;
}

#

const string USD = "USD";
const string GBP = "GBP";
const string CHF = "CHF";

var items = new[]
{
    new Trade(1, GBP, 100),
    new Trade(2, GBP, 200),
    new Trade(3, GBP, 100),
    new Trade(4, GBP, 200),
    new Trade(5, USD, 100),
    new Trade(6, USD, 200),
    new Trade(7, CHF, 100),
    new Trade(8, CHF, 200),
};

using (var source = new SourceCache<Trade, int>(t => t.Id))
using (var sut = new CustomTotalRows(source))
{
    source.AddOrUpdate(items);

    // should be 1 grand total row, 3 sub total rows, 8 rows
    Console.WriteLine(sut.AggregatedData.Count);  // 12
    Console.WriteLine(
      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.GrandTotal));
      // 1
    Console.WriteLine(
      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.SubTotal));
      // 3
    Console.WriteLine(
      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.Item)); 
      // 8
    foreach (var item in sut.AggregatedData.Items.OrderBy(tp => tp.Ticker))
    {
        Console.WriteLine(item);  
        // Should all be equivalent to CustomTotalRowsExpectation(source)
    }

    //remove all gbp rows. should be 1 grand total row, 2 sub total rows, 4 rows
    source.RemoveKeys(new[] { 1, 2, 3, 4 });
    Console.WriteLine(
      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.GrandTotal));
      // 1
    Console.WriteLine(
      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.SubTotal));
      // 2
    Console.WriteLine(
      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.Item)); 
      // 4
    foreach (var item in sut.AggregatedData.Items.OrderBy(tp => tp.Ticker))
    {
        Console.WriteLine(item);  
        // Should all be equivalent to CustomTotalRowsExpectation(source)
    }

    // add a previously unseen ticker - a new sub total row should have been added
    source.AddOrUpdate(new Trade(100, "TRY", 2000));
    Console.WriteLine(
      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.GrandTotal)); 
      // 1
    Console.WriteLine(
      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.SubTotal)); 
      // 3
    Console.WriteLine(
      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.Item)); 
      // 5
    foreach (var item in sut.AggregatedData.Items.OrderBy(tp => tp.Ticker))
    {
        Console.WriteLine(item);  
        // Should all be equivalent to CustomTotalRowsExpectation(source)
    }
}
```
#
```js
DynamicData.ObservableListEx.ChangeKey();
// Changes the primary key.

public static IObservable<IChangeSet<TObject, TDestinationKey>> 
    ChangeKey<TObject, TSourceKey, TDestinationKey>(this IObservable<IChangeSet<TObject, 
        TSourceKey>> source, Func<TObject, TDestinationKey> keySelector)
            where TSourceKey : notnull
            where TDestinationKey : notnull;
```
#
### 4. Custom Total Rows Expectation
```js
IEnumerable<TradeProxy> CustomTotalRowsExpectation(SourceCache<Trade, int> source)
{
    yield return new TradeProxy(
        source.Items.ToArray(), 
        new AggregationKey(AggregationType.GrandTotal, "All"));

    foreach (var proxy in source.Items
        .GroupBy(trade => new AggregationKey(AggregationType.Item, trade.Id.ToString()))
        .Select(g => new TradeProxy(g.ToArray(), g.Key)))
    {
        yield return proxy;
    }

    foreach (var proxy in source.Items
        .GroupBy(trade => new AggregationKey(AggregationType.SubTotal, trade.Ticker))
        .Select(g => new TradeProxy(g.ToArray(), g.Key)))
    {
        yield return proxy;
    }
}
```