---
title: Dynamic Data - Transform
date: '2021-01-12 06'
tag: DynamicData, TransformMany(), AutoRefreshOnObservable, ToObservableChangeSet
---
#
### 1. Flatten Observable Collection
* 중첩 된 관찰 가능 컬렉션을 기반으로 flat cache를 만든다.
* 부모가 추가 될 때마다 새로운 변경 집합이 생성되므로 Batch() 적용을 권장한다.
* 알림을 줄이기 위해 TransformMany() 이후(특히 초기로드시)
```js
public IObservableCache<NestedChild, string> Children { get; }

public FlattenNestedObservableCollection(
    IObservableCache<ClassWithNestedObservableCollection, int> source)
{
    Children = source
        .Connect()
        .TransformMany(parent => parent.Children, c => c.Name)
            // c.Name의 유일한 값들로 parent.Children를 flat 한다.
        .AsObservableCache();
}

#

var children = new[]
{
    new NestedChild("A", "ValueA"),
    new NestedChild("B", "ValueB"),
    new NestedChild("C", "ValueC"),
    new NestedChild("D", "ValueD"),
    new NestedChild("E", "ValueE"),
    new NestedChild("F", "ValueF")
};

var parents = new[]
{
    new ClassWithNestedObservableCollection(1, new[] { children[0], children[1] }),
    new ClassWithNestedObservableCollection(2, new[] { children[2], children[3] }),
    new ClassWithNestedObservableCollection(3, new[] { children[4] })
};

using (var source = new SourceCache<ClassWithNestedObservableCollection, int>(x => x.Id))
using (var sut = new FlattenNestedObservableCollection(source))
{
    source.AddOrUpdate(parents);

    Console.WriteLine(sut.Children.Count);  // 5
    foreach (var item in sut.Children.Items)
    {
        // parents.SelectMany(p => p.Children.Take(5))
        Console.WriteLine(item.Value);
    }

    // add a child to the observable collection
    parents[2].Children.Add(children[5]);
    Console.WriteLine(sut.Children.Count);  // 6
    Console.WriteLine(sut.Children.Items);  // parents.SelectMany(p => p.Children)

    // remove a parent and check children have moved
    source.RemoveKey(1);
    Console.WriteLine(sut.Children.Count);  // 4
    Console.WriteLine(sut.Children.Items);  // parents.SelectMany(p => p.Children)

    // add a parent and check items have been added back in
    source.AddOrUpdate(parents[0]);
    Console.WriteLine(sut.Children.Count);  // 6
    Console.WriteLine(sut.Children.Items);  // parents.SelectMany(p => p.Children)
}
```
#
### 2. Flatten Observable Collection With Projection From ObservableCache
```js
public int Id { get; }
public ObservableCollection<NestedChild> Children { get; }

public ClassWithNestedObservableCollection(int id, IEnumerable<NestedChild> animals)
{
    Id = id;
    Children = new ObservableCollection<NestedChild>(animals);
}

#

var children = new[]
{
    new NestedChild("A", "ValueA"),
    new NestedChild("B", "ValueB"),
    new NestedChild("C", "ValueC"),
    new NestedChild("D", "ValueD"),
    new NestedChild("E", "ValueE"),
    new NestedChild("F", "ValueF")
};

var parents = new[]
{
    new ClassWithNestedObservableCollection(1, new[] { children[0], children[1] }),
    new ClassWithNestedObservableCollection(2, new[] { children[2], children[3] }),
    new ClassWithNestedObservableCollection(3, new[] { children[4] })
};

using (var source = new SourceCache<ClassWithNestedObservableCollection, int>(x => x.Id))
using (var sut = source
        .Connect()
        .AutoRefreshOnObservable(self => self.Children.ToObservableChangeSet())
            // The refresh is triggered when the observable receives a notification.
        .TransformMany(
            parent => parent.Children.Select(c => new ProjectedNestedChild(parent, c)), 
            c => c.Child.Name)
                // parent.Children이 ProjectedNestedChild으로 new form된 것을 
                // c.Child.Name을 기준으로 flat ObservableCache를 만든다.
        .AsObservableCache())
{
    source.AddOrUpdate(parents);

    Console.WriteLine(sut.Count);  // 5
    foreach (var item in sut.Items)
        {
            // parents.SelectMany(
            //    p => p.children.Take(5).Select(c => new ProjectedNestedChild(p, c)));
            Console.WriteLine(item.Child.Value);
        }

    // add a child to the observable collection
    parents[2].Children.Add(children[5]);

    Console.WriteLine(sut.Count);  // 6
    Console.WriteLine(sut.Items);
    // parents.SelectMany(p => p.children.Select(c => new ProjectedNestedChild(p, c)));

    // remove a parent and check children have moved
    source.RemoveKey(1);
    Console.WriteLine(sut.Count);  // 4
    Console.WriteLine(sut.Items);
    // parents.SelectMany(
    //    p => p.children.skip(1).Select(c => new ProjectedNestedChild(p, c)));

    // add a parent and check items have been added back in
    source.AddOrUpdate(parents[0]);

    Console.WriteLine(sut.Count);  // 6
    Console.WriteLine(sut.Items);
    // parents.SelectMany(p => p.children.Select(c => new ProjectedNestedChild(p, c)));

}
```
```js
AutoRefreshOnObservable()
// Automatically refresh downstream operator. 
// The refresh is triggered when the observable receives a notification.

IObservable<IChangeSet<TObject, TKey>> 
    AutoRefreshOnObservable<TObject, TKey, TAny>(
        this IObservable<IChangeSet<TObject, TKey>> source, 
        Func<TObject, IObservable<TAny>> reevaluator, 
        TimeSpan? changeSetBuffer = null, 
        IScheduler? scheduler = null) where TKey : notnull;
```
```js
// 4. Creating Observable Change Sets : IObservable<IChangeSet<TObject,TKey>>

ToObservableChangeSet()  
// Convert an observable collection into an observable change set.

// 4.2 from an Rx Observable.
//     form an Observable Collection.
//     from an Binding List.
IObservable<IChangeSet<TObject,TKey>> 
    IObservable<IEnumerable<T>>.ToObservableChangeSet(t=> t.key);
```
#
### 3. Flatten Observable Collection With Projection From ObservableList
```js
public class ProjectNestedChildEqualityComparer : IEqualityComparer<ProjectedNestedChild>
{
    public bool Equals(ProjectedNestedChild x, ProjectedNestedChild y)
    {
        if (x == null || y == null)
        {
            return false;
        }

        return x.Child.Name == y.Child.Name;
    }

    public int GetHashCode([DisallowNull] ProjectedNestedChild obj)
    {
        return obj.Child.Name.GetHashCode();
    }
}

#

using (var source = new SourceList<ClassWithNestedObservableCollection>())
using (var sut = source
        .Connect()
        .AutoRefreshOnObservable(self => self.Children.ToObservableChangeSet())
        .TransformMany(
            parent => parent.Children.Select(c => new ProjectedNestedChild(parent, c)), 
            new ProjectNestedChildEqualityComparer())
            // IEqualityComparer<ProjectedNestedChild>를 
            // 이용해 flat ObservableList를 만든다.
        .AsObservableList())
{
    source.AddRange(parents);

    Console.WriteLine(sut.Count);  // 5
    Console.WriteLine(sut.Items);
    // parents.SelectMany(
    //    p => p.Children.Take(5).Select(c => new ProjectedNestedChild(p, c)))

    // add a child to the observable collection
    parents[2].Children.Add(children[5]);
    Console.WriteLine(sut.Count);  // 6
    Console.WriteLine(sut.Items);
    // parents.SelectMany(p => p.Children.Select(c => new ProjectedNestedChild(p, c)))

    // remove a parent and check children have moved
    source.Remove(parents[0]);
    Console.WriteLine(sut.Count);  // 4
    Console.WriteLine(sut.Items);
    // parents.SelectMany(
    //    p => p.Children.Skip(1).Select(c => new ProjectedNestedChild(p, c)))

    // add a parent and check items have been added back in
    source.Add(parents[0]);

    Console.WriteLine(sut.Count);  // 6
    Console.WriteLine(sut.Items);
    // parents.SelectMany(p => p.Children.Select(c => new ProjectedNestedChild(p, c)))
}
```