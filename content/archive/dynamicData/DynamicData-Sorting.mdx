---
title: Dynamic Data - Sorting
date: '2021-01-12 07'
tag: DynamicData, Sort, Threshold, Ascending, Decending, SortExpressionComparer, AsObservableList(), ISourceList<T>, IObservableList<T>
---
#
### 1. Custom Binding
* 재설정 임계값(reset threshold)을 동적으로 제어될 수 있는지에 대한 확인.
```js
/*
    Sometimes the default binding does not behave exactly as you want.
    Using VariableThresholdObservableCollectionAdaptor is an example of 
    how you can inject your own behaviour.
*/

public CustomBinding(IObservableCache<Animal, string> source)
{
    Threshold = 5;

    this.cleanUp = source
        .Connect()
        .Sort(SortExpressionComparer<Animal>.Ascending(a => a.Name))
        .Bind(
          out var data, 
          adaptor: new VariableThresholdObservableCollectionAdaptor<Animal, string>(
            () => Threshold))
        .Subscribe();

    Data = data;
}

#

Animal[] items = new[]
    {
        new Animal("Holly", "Cat", AnimalFamily.Mammal),
        new Animal("Rover", "Dog", AnimalFamily.Mammal),
        new Animal("Rex", "Dog", AnimalFamily.Mammal),
        new Animal("Whiskers", "Cat", AnimalFamily.Mammal),
        new Animal("Nemo", "Fish", AnimalFamily.Fish),
        new Animal("Moby Dick", "Whale", AnimalFamily.Mammal),
        new Animal("Fred", "Frog", AnimalFamily.Amphibian),
        new Animal("Isaac", "Next", AnimalFamily.Amphibian),
        new Animal("Sam", "Snake", AnimalFamily.Reptile),
        new Animal("Sharon", "Red Backed Shrike", AnimalFamily.Bird),
    };

using (var sourceCache = new SourceCache<Animal, string>(a => a.Name))
using (var sut = new CustomBinding(sourceCache))
{
    int resetCount = 0;
    (sut.Data as INotifyCollectionChanged).CollectionChanged += (_, e) =>
    {
        if (e.Action == NotifyCollectionChangedAction.Reset)
        {
            resetCount++;
        }
    };

    sut.Threshold = 20;
    sourceCache.AddOrUpdate(items);
    Console.WriteLine(resetCount);  // 0

    sut.Threshold = 9;  // itmes.Count > sut.Threshold { resetCount++ }
                        // 수용 임계치가 컬렉션의 카운트보다 작다.
                        // 그래서 컬렉션 체인지가 발생한다.
    sourceCache.AddOrUpdate(items);
    Console.WriteLine(resetCount);  // 1

    sut.Threshold = 20;
    sourceCache.AddOrUpdate(items);
    Console.WriteLine(resetCount);  // 1

    sut.Threshold = 5;  // itmes.Count > sut.Threshold { resetCount++ }
    sourceCache.AddOrUpdate(items);
    Console.WriteLine(resetCount);  // 2
}
```
#
### 2. Change Comparer
* IObservable`<IComparer<T>>`를 연산자 Sort()에 전달하여 정렬(sorting)을 전환한다.
* 동일한 개념이 ObservableCache에도 적용된다.
```js
public ChangeComparereOption Option
{
    get => this.option;
    set => SetAndRaise(ref this.option, value);
}
public IObservableList<int> DataSource { get; }

public ChangeComparer(IObservableList<int> source)
{
    IObservable<SortExpressionComparer<int>> optionChanged = this
        .WhenValueChanged(@this => @this.Option)
        .Select(opt => opt == ChangeComparereOption.Ascending
            ? SortExpressionComparer<int>.Ascending(i => i)
            : SortExpressionComparer<int>.Descending(i => i));

    // create a sorted observable list
    DataSource = source
        .Connect()
        .Sort(optionChanged)
        .AsObservableList();

    this.cleanUp = DataSource;
}

#

using (var input = new SourceList<int>())
using (var sut = new ChangeComparer(input))
{
    input.AddRange(randomValues);
    Console.WriteLine(sut.DataSource.Items);  // Should all be equivalent to ascending

    sut.Option = ChangeComparereOption.Descending;
    Console.WriteLine(sut.DataSource.Items);  // Should all be equivalent to descending

    sut.Option = ChangeComparereOption.Ascending;
    Console.WriteLine(sut.DataSource.Items);  // Should all be equivalent to ascending
}
```
#
```js
// DynamicData.SourceList<T> : ISourceList<T>, IObservableList<T>, IDisposable

public sealed class SourceList<T> : ISourceList<T>, IObservableList<T>, IDisposable
{
    public SourceList(IObservable<IChangeSet<T>>? source = null);

    public int Count { get; }
    public IObservable<int> CountChanged { get; }
    public IEnumerable<T> Items { get; }

    public IObservable<IChangeSet<T>> Connect(Func<T, bool>? predicate = null);
    public void Dispose();
    public void Edit(Action<IExtendedList<T>> updateAction);
    public IObservable<IChangeSet<T>> Preview(Func<T, bool>? predicate = null);
}

// 읽기전용으로 파생 컬렉션을 만들어 노출
// IObservable<IChangeSet<T>>.AsObservableList()
// return type : IObservableList<T>

// IObservableList<T>.Connect()
// return type : IObservable<IChangeSet<T>>
```
#
```js
// DynamicData.IObservableList<T>
// A readonly observable list, 
// providing observable methods as well as data access methods.

public interface IObservableList<T> : IDisposable
{
    // Gets the count.
    int Count { get; }

    // Gets observe the count changes, starting with the initial items count.
    IObservable<int> CountChanged { get; }

    // Gets items enumerable.
    IEnumerable<T> Items { get; }

    // Connect to the observable list 
    // and observe any changes starting with the list's initial items.
    IObservable<IChangeSet<T>> Connect(Func<T, bool>? predicate = null);

    // Connect to the observable list 
    // and observe any changes before they are applied to the list. 
    // Unlike Connect(), the returned observable is not prepended with
    // the lists initial items.
    IObservable<IChangeSet<T>> Preview(Func<T, bool>? predicate = null);
}
```
#
```js
DynamicData.ObservableListEx.AsObservableList();
// Converts the source observable to an read only observable list.

public static IObservableList<T> 
        AsObservableList<T>(this ISourceList<T> source); 

public static IObservableList<T> 
        AsObservableList<T>(this IObservable<IChangeSet<T>> source);
```