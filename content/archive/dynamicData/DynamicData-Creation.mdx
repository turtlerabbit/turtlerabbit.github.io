---
title: Dynamic Data - Change Set Creation
date: '2021-01-12 01'
tag: DynamicData, SourceList, SourceCache, ObservableChangeSet, Task, Reloadable, Switch(), EditDiff(), RefCount(), Retry()
---
#
### 1. FromObservable
2개의 observables를 받아 하나의 `IObservable<IChangeSet<T, TKey>>`을 만들어 반환한다.  
#
```js
// BehaviorSubject : 가장 마지막의 값(데이터 소스)을 캐싱해서 보여주는 subject.
// 만약 마지막의 1개의 이벤트를 배출하고 싶다면 BehaviorSubject를 사용.
var initial = new BehaviorSubject<IEnumerable<DataClass>>(Generator.Generate(5));
var subscriptions = new Subject<DataClass>();

#

return ObservableChangeSet.Create<DataClass, long>(cache =>
{
    // in an enterprise app, 
    // would have to account for the gap between load and subscribe
    var initialSubscriber = initialLoad
        .Take(1)
        .Subscribe(cache.AddOrUpdate);

    var subscriber = subscriptions
        .Subscribe(cache.AddOrUpdate);

    return new CompositeDisposable(initialSubscriber, subscriber);
}, DataClass => DataClass.Id);

#

subscriptions.OnNext(newItem); // count: 6
```
#
### 2. FromTask
Create an observable change set from a `Task`
```js
return ObservableChangeSet.Create<DataClass, long>(async cache =>
{
    var items = await LoadFromTask();
    cache.AddOrUpdate(items);
    return () => { };
}, DataClass => DataClass.Id); 

#

public static Task<IEnumerable<DataClass>> LoadFromTask()
{
    return Task.FromResult(Generator.Generate(6));
}
```
#
### 3. Reloadable
DynamicData의 `Switch()` 연산자를 사용하여 반복적으로 data를 다시 로드한다.
#
```js
Switch()  // 이전 data를 지우고 새로이 로드된 data를 추가하는 기능

IObservable<IChangeSet<TObject, TKey>> 
    Switch<TObject, TKey>(this IObservable<IObservableCache<TObject, TKey>> sources);
```
#
```js
var loader = new Subject<Unit>();
int loadCount = 0;

#

public static IObservable<IChangeSet<DataClass, long>>
    Reloadable(IObservable<Unit> loadObservable)
{
    return loadObservable
        .StartWith(Unit.Default)
        .Select(_ => FromTask())
        .Switch();
}

#

ChangeSetCreation
    .Reloadable(loader)
    .Do(Change => loadCount++)
    .AsObservableCache()

loader.OnNext(Unit.Default);

// the count will be 3 rather than 2 
// because a .Clear() is first called (이전 데이터를 모드 지우고)
// when an observable change set is switched
```
#
### 4. Reloadable With EditDiff
노이즈를 크게 줄일 수 있는 `불필요한 업데이트를 예방`하기 위해 
이전 로드와의 diff set를 계산하는 `ISourceCache<TObject, TKey>.EditDiff()`를 사용하여
다시 로드하고 목록을 유지한다.
```js
var reloader = new Subject<Unit>();
int loadCount = 0;
IChangeSet<DataClass, long> lastChangeSet = null;

Task<IEnumerable<DataClass>> Loader()
{
    loadCount++;
    return Task.FromResult(loadCount == 1
        ? Generator.Generate(6)
        : Generator.Generate(11));
}

#

return ObservableChangeSet.Create<DataClass, long>(cache =>
{
    return loadObservable
        .StartWith(Unit.Default)  // ensure inital load
        .SelectMany(_ => loader()) // SelectMany : From one, select 0 or more
        .Subscribe(items => 
        {
          cache.EditDiff(items, EqualityComparer<DataClass>.Default)
        });
}, dataClass => dataClass.Id);

#

ChangeSetCreation
    .ReloadableWithEditDiff(reloader, Loader)
    .Do(changes => lastChangeSet = changes)
    .AsObservableCache()

reloader.OnNext(Unit.Default);
```
#
### 5. FromTask With RefCount
구독이 하나 이상 있는 한 소스에 연결된 상태로 유지되는 시퀀스를 반환한다.  
구독이 0이면 자신을 해지하고 다시 새로운 구독이 오면 처음부터 자동으로 시작한다.
#
```js
RefCount()  // Cache equivalent to Publish().RefCount(). 
            // The source is cached so long as there is at least 1 subscriber.

IObservable<IChangeSet<TObject, TKey>> 
    RefCount<TObject, TKey>(this IObservable<IChangeSet<TObject, TKey>> source);
```
#
```js
public static IObservable<IChangeSet<DataClass, long>>
    FromTaskWithRefCount(Func<Task<IEnumerable<DataClass>>> loader)
{
    // RefCount는 표준 rx Publish().RefCount() 작업의 dd 오버로드이다.
    // dd가 자동으로 처리하므로 Publish()를 사용하지 않는다.
    return FromTask(loader).RefCount();            
}

public static IObservable<IChangeSet<DataClass, long>> 
    FromTask(Func<Task<IEnumerable<DataClass>>> loader)
{
    return ObservableChangeSet.Create<DataClass, long>(async cache =>
    {
        var items = await loader();
        cache.AddOrUpdate(items);
        return () => { };
    }, dataClass => dataClass.Id);
}

#

int loadCount = 0;
Task<IEnumerable<DataClass>> Loader()
{
    loadCount++;
    return Task.FromResult(Generator.Generate(6));
}

var refcountSource = ChangeSetCreation.FromTaskWithRefCount(Loader);

using (var sut1 = refcountSource.AsObservableCache())
using (var sut2 = refcountSource.AsObservableCache())
{
    Console.WriteLine(sut1.Count);
    Console.WriteLine(sut2.Count);
    // 구독이 하나이상 한 소스에 연결된 상태로 유지
}
Console.WriteLine(loadCount); // 그래서 loadCount는 1

// 구독 0 상태

using (var sut1 = refcountSource.AsObservableCache())
using (var sut2 = refcountSource.AsObservableCache())
using (var sut3 = refcountSource.AsObservableCache())
using (var sut4 = refcountSource.AsObservableCache())
using (var sut5 = refcountSource.AsObservableCache())
{
    // 다시 새로운 구독으로 처음부터 자동으로 시작.
    Console.WriteLine(sut1.Count);
    Console.WriteLine(sut2.Count);
    Console.WriteLine(sut3.Count);
    Console.WriteLine(sut4.Count);
    Console.WriteLine(sut5.Count);
    // 구독이 하나이상 한 소스에 연결된 상태로 유지
}
Console.WriteLine(loadCount); // 그래서 loadCount 2
```
#
### 6. WithRetry
`Retry()` : In an enterprise app, would probably use a backoff retry strategy
```js
int loadCount = 0;
int failedCount = 0;

Task<IEnumerable<DataClass>> Loader()
{
    loadCount++;

    if (loadCount < 3)
    {
        failedCount++;
        throw new Exception("Failed");
    }
    return Task.FromResult(Generator.Generate(6));
}

#

ChangeSetCreation
    .FromTask(Loader)
    .Retry(3)
    .AsObservableCache()
```