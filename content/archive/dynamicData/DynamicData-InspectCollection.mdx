---
title: Dynamic Data - Inspect Collection
date: '2021-01-12 02'
tag: DynamicData, Collection, ToCollection(), Select(), AutoRefresh(), CombineLatest(), MergeMany(), StartWith(), Publish(), WhenAnyPropertyChanged(), WhenPropertyChanged(), Filter(), StartWithEmpty(), IConnectableObservable, IConnectableCache, Connect()
---
#
### 1. Inspect Collection
소스의 항목이 추가 되거나 제거 될 때 전체 컬렉션을 검사하는 방법을 보여준다.  
```js
ObservableCacheEx.ToCollection();  
// change set을 완전한 형식의 컬렉션으로 변환한다.

IObservable<IReadOnlyCollection<TObject>> 
    IObservable<IChangeSet<TObject, TKey>>.ToCollection<TObject, TKey>();  
```
```js
Observable.Select();  
// Projects each element of an observable sequence into a new form.

IObservable<TResult> 
    IObservable<IReadOnlyCollection<TObject>>.Select();
```
```js
this.cleanUp = source
    .Connect()
    .ToCollection()  // 소스가 변경 될 때마다 새 컬렉션이 생성된다.
    .Select(items =>
    {
        return new
        {
            DistinctCount = items.Select(x => x.Value).Distinct().Count(),
            Count = items.Count
        };
    })
    .Subscribe(x =>
    {
        DistinctCount = x.DistinctCount;
        Count = x.Count;
    });
```
#
```js
`IReadOnlyCollection<out T>`  // Represents a strongly-typed, 
                              // read-only collection of elements.
 
public interface IReadOnlyCollection<out T> : IEnumerable<T>, IEnumerable
{
    // 요약:
    //     Gets the number of elements in the collection.
    //
    // 반환 값:
    //     The number of elements in the collection.
    int Count { get; }
}
```
#
### 2. Inspect Collection With PropertyChanges
 형식 매개변수 `TObject의 속성이 변경 될 때` 전체 컬렉션을 검사하는 방법을 보여준다.  

```js
ObservableCacheEx.AutoRefresh();
// Automatically refresh downstream operators when properties change.

IObservable<IChangeSet<TObject, TKey>> 
    IObservable<IChangeSet<TObject, TKey>>.AutoRefresh<TObject, TKey, TProperty>()
    
```
```js
this.cleanUp = source
    .Connect()
    .AutoRefresh(vm => vm.IsActive)  // vm은 TObject, TObject.Property가 변경 될 때
    .ToCollection()  // 소스의 항목인 TObject가 추가되거나 삭제 될 때
    .Select(items =>
    {
        return new
        {
            // produce a new result 
            // when the collection itself changes, 
            // or when IsActive changes(any result can be returned)
            AllActive = items.All(i => i.IsActive),
            AllInActive = items.All(i => !i.IsActive),
            AnyActive = items.Any(i => i.IsActive),
            Count = items.Count,
        };
    })
    .Subscribe(x =>
    {
        AllActive = x.AllActive;
        AllInActive = x.AllInActive;
        AnyActive = x.AnyActive;
        Count = x.Count;
    });
```
#
### 3. Inspect Collection With Observable
전체 컬렉션을 검사하고 관찰 가능한 상태를 대조하는 방법을 보여준다.

```js
ObservableCacheEx.Transform();  
// 지정된 변환 함수를 사용하여 각 업데이트 항목을 새 양식에 투영한다.

IObservable<IChangeSet<TDestination, TKey>> 
    IObservable<IChangeSet<TObject, TKey>>.Transform<TDestination, TSource, TKey>();
```
#
```js
Observable.Publish();  
// Returns a connectable observable sequence 
// that shares a single subscription to the underlying sequence.
// 이 연산자는 일반 System.Reactive.Subjects.Subject`1을 
// 사용하는 멀티 캐스트의 전문화이다.

IConnectableObservable<IChangeSet<TDestination, TKey>> 
    IObservable<IChangeSet<TDestination, TKey>>.Publish<TSource>();
```
#
```js
ObservableCacheEx.MergeMany();  
//  스트림의 각 항목에서 선택된 Observable을 동적으로 병합한다.
//  더 이상 스트림의 일부가 아닐 때 항목을 병합 해제한다.

IObservable<bool> 
    IObservable<IChangeSet<TObject, TKey>>.MergeMany<TObject, TKey, TDestination>();
```
#
```js
Observable.StartWith();  
// Prepends a sequence of values to an observable sequence.

IObservable<TSource> 
    StartWith<TSource>(this IObservable<TSource> source, params TSource[] values);
```
#
```js
Observable.CombineLatest();  
// Merges two observable sequences into one observable sequence 
// by using the selector function 
// whenever one of the observable sequences produces an element.

IObservable<TResult> CombineLatest<TSource1, TSource2, TResult>
    (this IObservable<TSource1> first, 
          IObservable<TSource2> second, 
          Func<TSource1, TSource2, TResult> resultSelector);

          // resultSelector: 소스 중 하나가 요소를 생성 할 때마다 호출하는 function.
```
#
```js
// 컬렉션의 각 항목에 대한 IsActive observable 알림의 상태를 캡처
var observableWithState = source
    .Connect()
    .Transform(obj => new ObservableState(obj))
    .Publish();

// 내부 observables의 항목이 변경되었을 때, 
// observable을 실행(활성화)하기 위한 기능
var activeChanged = observableWithState
    .MergeMany(state => state.IsActive)  // IObservable<bool> IsActive
    // 항목이 기본 목록에 추가 될 때 observable을 자동으로 연결하고 
    // 항목이 제거되면 연결을 해제
    .Select(_ => Unit.Default)  // To Unit
    // 빈 값을 가진 항목을 방출하기 위한 작업.
    // acitveChanged는 observable의 활성화, 비활성를 나타내는 기능만 필요하기 때문.
    .StartWith(Unit.Default);  
    // collection이 로드 될 때 최신 yields를 결합하기 위해 unit으로 시작.

// 기본 observable 목록이 변경 될 때(추가, 제거 및 교체) 
// 전체 컬렉션을 공개(reveal)한다.
var collectionChanged = observableWithState.ToCollection();

// 최신 컬렉션과 observable 알림을 결합하고 모든 항목이 활성 상태인지 여부를 
// 나타내는 결과를 생성한다.
var areAllActive = collectionChanged
    .CombineLatest(activeChanged, (items, _) =>
    {
        // collectionChanged, activeChanged 중 하나가 요소를 생성 할 때마다 
        // 호출하는 function.

        return items.Any() &&
        items.All(state => 
        {
          state.LatestValue.HasValue && state.LatestValue == true;
        });
    });

this.cleanUp = new CompositeDisposable
(
    areAllActive.Subscribe(allActive => AllActive = allActive),
    observableWithState.Connect()
);

#

var initialItems = Generate(6);

sourceCache.AddOrUpdate(initialItems);
System.Console.WriteLine(sut.AllActive); // false

// should remain false because
initialItems.ElementAt(1).SetIsActive(true);
System.Console.WriteLine(sut.AllActive); // false

// set all items to true
foreach (var item in initialItems)
{
    item.SetIsActive(true);
}
```
#
```js
Connect();  

#
// 기본 시퀀스에 대한 단일 구독을 공유하기 위해
// IObservable<IChangeSet<Trade, long>>.Publish()
// return type : IConnectableObservable<IChangeSet<Trade, long>>

public interface IConnectableObservable<out T> : IObservable<T>
{
    // 요약:
    //     Connects the observable wrapper to its source. 
    //     All subscribed observers will receive values 
    //     from the underlying observable sequence 
    //     as long as the connection is established.
    IDisposable Connect();    
}

#
// 읽기전용으로 파생 컬렉션을 만들어 노출하기 위해
// IConnectableObservable<IChangeSet<Trade, long>>.AsObservableCache()
// return type : IConnectableCache<Trade, long>

public interface IConnectableCache<TObject, TKey> where TKey : notnull
{
    // 요약:
    //     Returns a filtered stream of cache changes 
    //     preceded with the initial filtered tate.
    
    // 매개 변수:
    //   predicate:
    //     The result will be filtered using the specified predicate.
    
    // 반환 값:
    //     An observable that emits the change set.
    IObservable<IChangeSet<TObject, TKey>> 
        Connect(Func<TObject, bool>? predicate = null);
}
```
#
### 4. Monitor SelectedItems
Both methods produce the same result.  
그러나, UsingEntireCollection()은 선택된 항목과 선택되지 않은 항목의 값을 생성 할 수 있다.
#
```js
ObservableCacheEx.WhenPropertyChanged();  
// 컬렉션의 각 항목을 보고 변경된 항목이 있으면 알린다.

IObservable<PropertyValue<TObject, TValue>> 
    WhenPropertyChanged<TObject, TKey, TValue>(
        this IObservable<IChangeSet<TObject, TKey>> source, 
        Expression<Func<TObject, TValue>> propertyAccessor, 
        bool notifyOnInitialValue = true)
```
#
```js
ObservableCacheEx.Filter();  // Filters the specified source.

IObservable<IChangeSet<TObject, TKey>> 
    IObservable<IChangeSet<TObject, TKey>>.Filter<TObject, TKey>(
        this IObservable<IChangeSet<TObject, TKey>> source, 
        Func<TObject, bool> filter)
```
#
```js
ObservableCacheEx.StartWithEmpty();  
// Prepends an empty change set to the source.

IObservable<IReadOnlyCollection<T>> 
    StartWithEmpty<T>(this IObservable<IReadOnlyCollection<T>> source);
```
#
```js
private IDisposable UseFilterOnProperty()
{
    var selectedItems = this.source
        .Connect()
        .AutoRefresh(si => si.IsSelected)
        .Filter(si => si.IsSelected)
        .ToCollection()
        .StartWithEmpty()
        .Publish();

    return new CompositeDisposable
    (
        selectedItems
        .Select(items => items.Any(si => si.IsSelected))
        .Subscribe(result => HasSelection = result),

        selectedItems
        .Select(items =>
        {
            var count = items.Count(si => si.IsSelected);
            if (count == 0) return "Nothing Selected";
            return count == 1 
                ? $"{count} item selected" : $"{count} items selected";
        })
        .Subscribe(result => SelectedMessage = result),

        selectedItems.Connect()
    );
}
```
#
```js
private IDisposable UseEntireCollection()
{
    // 기본 목록이 변경되거나 IsSelected가 변경 될 때 관찰 가능 항목을 생성
    var shared = this.source.Connect().Publish();

    var selectedChanged = shared
        .WhenPropertyChanged(si => si.IsSelected)
        .Select(_ => Unit.Default)
        .StartWith(Unit.Default);

    var collectionChanged = shared
        .ToCollection()
        .CombineLatest(selectedChanged, (items, _) => items)
        .Publish();

    return new CompositeDisposable
    (
        collectionChanged
        .Select(items => items.Any(si => si.IsSelected))
        .Subscribe(result => HasSelection = result),

        collectionChanged
        .Select(items =>
        {
            var count = items.Count(si => si.IsSelected);
            if (count == 0) return "Noting Selected";
            return count == 1
            ? $"{count} item selected" : $"{count} items selected";
        })
        .Subscribe(result => SelectedMessage = result),
        shared.Connect(),

        collectionChanged.Connect()
    );
}
```