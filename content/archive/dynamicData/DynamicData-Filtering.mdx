---
title: Dynamic Data - Filtering
date: '2021-01-12 08'
tag: DynamicData, Filtering, IObservableList<T>, AsObservableList(), SourceList<T>, FilterOnProperty()
---
#
### 1. Static Filter
* 기본 목록이 추가 또는 삭제를 수신 할 때만 Mammals별로 자동 필터링된다.
```js
public StaticFilter(IObservableList<Animal> source)
{
    // 이 목록은 기본 목록이 추가 또는 제거를 수신 할 때만
    // Mammals별로 자동 필터링된다.
    Mammals = source
        .Connect()
        .Filter(animal => animal.Family == AnimalFamily.Mammal)
        .AsObservableList();

    this.cleanUp = Mammals;
}

#

using (var sourceList = new SourceList<Animal>())
using (var sut = new StaticFilter(sourceList))
{
    sourceList.AddRange(items);

    // items.Where(a=>a.Family == AnimalFamily.Mammal)
    Console.WriteLine(sut.Mammals.Items);
    Console.WriteLine(sut.Mammals.Count);  // 5

    // add a new mammal to show it is included in the result set
    sourceList.Add(new Animal("Bob", "Human", AnimalFamily.Mammal));
    Console.WriteLine(sut.Mammals.Count);  // 6

    // remove the first 4 items which will leave 2 mammals
    sourceList.RemoveRange(0, 4);
    Console.WriteLine(sut.Mammals.Count); // 2
}
```
#
```js
// DynamicData.IObservableList<T>
// A readonly observable list, 
// providing observable methods as well as data access methods.

public interface IObservableList<T> : IDisposable
{
    // Gets the count.
    int Count { get; }

    // Gets observe the count changes, starting with the initial items count.
    IObservable<int> CountChanged { get; }

    // Gets items enumerable.
    IEnumerable<T> Items { get; }

    // Connect to the observable list 
    // and observe any changes starting with the list's initial items.
    IObservable<IChangeSet<T>> Connect(Func<T, bool>? predicate = null);

    // Connect to the observable list 
    // and observe any changes before they are applied to the list. 
    // Unlike Connect(), the returned observable is not prepended with
    // the lists initial items.
    IObservable<IChangeSet<T>> Preview(Func<T, bool>? predicate = null);
}
```
#
#
```js
// DynamicData.SourceList<T> : ISourceList<T>, IObservableList<T>, IDisposable

public sealed class SourceList<T> : ISourceList<T>, IObservableList<T>, IDisposable
{
    public SourceList(IObservable<IChangeSet<T>>? source = null);

    public int Count { get; }
    public IObservable<int> CountChanged { get; }
    public IEnumerable<T> Items { get; }

    public IObservable<IChangeSet<T>> Connect(Func<T, bool>? predicate = null);
    public void Dispose();
    public void Edit(Action<IExtendedList<T>> updateAction);
    public IObservable<IChangeSet<T>> Preview(Func<T, bool>? predicate = null);
}

// 읽기전용으로 파생 컬렉션을 만들어 노출
// IObservable<IChangeSet<T>>.AsObservableList()
// return type : IObservableList<T>

// IObservableList<T>.Connect()
// return type : IObservable<IChangeSet<T>>
```
#
```js
DynamicData.ObservableListEx.AsObservableList();
// Converts the source observable to an read only observable list.

public static IObservableList<T> 
        AsObservableList<T>(this ISourceList<T> source); 

public static IObservableList<T> 
        AsObservableList<T>(this IObservable<IChangeSet<T>> source);
```
#
### 2. Dynamic Filter
* Create list which automatically filters when AnimalFilter changes
```js
public IObservableList<Animal> Filtered { get; }

public DynamicFilter(IObservableList<Animal> source, ISchedulerProvider schedulerProvider)
{
    // AnimalFilter 속성이 변경 될 때마다 new predicate를 생성하는 observable을 생성한다.
    var dynamicFilter = this
        .WhenValueChanged(@this => @this.AnimalFilter)
        .Throttle(TimeSpan.FromMilliseconds(250), schedulerProvider.Background)
        //throttle to prevent constant filtering (i.e. when users type)
        .Select(CreatePredicate);

    // Create list which automatically filters when AnimalFilter changes
    Filtered = source
        .Connect()
        .Filter(dynamicFilter)
        // dynamicfilter는 관찰 가능한 모든 술어를 허용 할 수 있다.
        // (즉, 속성을 기반으로하지 않아도 됨).
        .AsObservableList();

    this.cleanUp = Filtered;
}

private Func<Animal, bool> CreatePredicate(string text)
{
    if (text == null || text.Length < 3)
    {
        return animal => true;
    }

    // the more fields which are filtered on the slower it takes for the filter to apply 
    // by generally I have never found checking a predicate to be particularly slow 
    return animal => animal.Name.Contains(text)
                        || animal.Type.Contains(text)
                        || animal.Family.ToString().Contains(text);
}

#

var schedulerProvider = new TestSchedulerProvider();
using (var sourceList = new SourceList<Animal>())
using (var sut = new DynamicFilter(sourceList, schedulerProvider))
{
    // add items
    sourceList.AddRange(items);

    Console.WriteLine(sut.Filtered.Count);

    // set a filter
    sut.AnimalFilter = "Dog";  // items.Where(a=>a.Type == "Dog")

    Console.WriteLine(sut.Filtered.Count);  // 2

    // add a new dog to show it is included in the result set
    sourceList.Add(new Animal("George", "Dog", AnimalFamily.Mammal));

    Console.WriteLine(sut.Filtered.Count);  // 3

    // add a new bird to show it is included in the result set
    sourceList.Add(new Animal("Peter", "Parrot", AnimalFamily.Bird));

    Console.WriteLine(sut.Filtered.Count);  // 3

    // My additions...
    sut.AnimalFilter = "Frog"; // items.Where(a => a.Type == "Frog")

    Console.WriteLine(sut.Filtered.Count);  // 1
}
```
#
### 3. Property Filter
* 자동으로 필터링하는 목록 만들기
```js
public class PropertyFilter : AbstractNotifyPropertyChanged, IDisposable
{
    private readonly IDisposable cleanUp;
    public IObservableList<Animal> Filtered { get; }

    public PropertyFilter(IObservableList<Animal> source, 
                            ISchedulerProvider schedulerProvider)
    {
        /*
        *  Create list which automatically filters : 
        *  
        *  a) 기본 목록이 변경 될 때
        *  b) IncludeInResults 속성이 변경되는 경우
        *  c) 주의 : IncludeInResults 속성이 빠른 sucession으로 multiple animals에서 
        *            변경 될 수 있는 경우 throttle를  추가한다.
        *            (즉, 소품이 변경 될 때마다 필터가 재평가되어 잠재적으로 
        *                 업데이트가 급증 할 수 있다. 속도를 늦추는 것이 좋다.)
        */

        Filtered = source
            .Connect()
            .FilterOnProperty(
                animal => animal.IncludeInResults,
                animal => animal.IncludeInResults,
                TimeSpan.FromMilliseconds(250),
                schedulerProvider.MainThread)
            .AsObservableList();
    }

    public void Dispose()
    {
        this.cleanUp.Dispose();
    }
}

#

var schedulerProvider = new TestSchedulerProvider();
using (var sourceList = new SourceList<Animal>())
using (var sut = new PropertyFilter(sourceList, schedulerProvider))
{
    // add items
    sourceList.AddRange(items);
    Console.WriteLine(sut.Filtered.Count);  // 0

    // set to true to include in the result set
    items[1].IncludeInResults = true;
    items[2].IncludeInResults = true;
    items[3].IncludeInResults = true;

    Console.WriteLine(sut.Filtered.Items);  // itmes[1], items[2], items[3]
}
```
#
```js
DynamicData.ObservableListEx.FilterOnProperty();
// buffer의 작업 결과를 change set로 변환한다.

public static IObservable<IChangeSet<TObject>> 
    FilterOnProperty<TObject, TProperty>(this IObservable<IChangeSet<TObject>> source, 
        Expression<Func<TObject, TProperty>> propertySelector, 
        Func<TObject, bool> predicate, TimeSpan? propertyChangedThrottle = null, 
        IScheduler? scheduler = null) where TObject : INotifyPropertyChang

```
#
### 4. External Source Filter
* 다른 필터의 결과에서 필터링 된 목록 만들기
```js
public class ExternalSourceFilter : AbstractNotifyPropertyChanged, IDisposable
{
    private readonly IDisposable cleanUp;
    public IObservableList<Animal> Filtered { get; }

    public ExternalSourceFilter(IObservableList<Animal> source, 
                                    IObservableList<AnimalFamily> families)
    {
        /*
         *  Create list which is filtered from the result of another filter
         */

        var familyFilter = families
            .Connect()
            .ToCollection()
            .Select(items =>
            {
                bool Predicate(Animal animal) => items.Contains(animal.Family);
                return (Func<Animal, bool>)Predicate;
            });

        Filtered = source
            .Connect()
            .Filter(familyFilter)
            .AsObservableList();

        this.cleanUp = Filtered;
    }

    public void Dispose()
    {
        this.cleanUp.Dispose();
    }
}

#

using (var sourceList = new SourceList<Animal>())
using (var families = new SourceList<AnimalFamily>())
using (var sut = new ExternalSourceFilter(sourceList, families))
{
    // add items to source
    sourceList.AddRange(items);
    Console.WriteLine(sut.Filtered.Count);  // 0

    families.AddRange(new []{ AnimalFamily.Amphibian, AnimalFamily.Bird });
    Console.WriteLine(sut.Filtered.Items);  
    //  items.Where(a => a.Family == AnimalFamily.Amphibian 
    //  || a.Family==AnimalFamily.Bird)

    families.Remove(AnimalFamily.Amphibian);
    Console.WriteLine(sut.Filtered.Items);  
    //  Where(a => a.Family == AnimalFamily.Bird)
}
```