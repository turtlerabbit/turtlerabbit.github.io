---
title: IEquatable<T>
date: '2021-01-09 01'
tag: csharp, grammar, IEquatable, Equals(), GetHashCode()
---

[참고] CLR via c# 4th (p163)

클래스의 개체가 배열 또는 제네릭 컬렉션 개체에 저장 될 가능성을 처리하려면 개체를 
쉽게 식별하고 조작 할 수 있도록 `IEquatable<T>`를 구현하는 것이 좋다. 주된 이유는 성능이다.

Equals(T)를 구현하는 경우 Equals(Object) 및 GetHashCode()의 기본 클래스 구현도 
재정의하여 해당 동작이 Equals(T) 메서드의 동작과 일치하도록해야한다. 

Equals(Object)를 재정의하는 경우 재정의 된 구현은 클래스의 static Equals(System.Object, System.Object) 
메서드에 대한 호출에서도 호출된다.

- Person.Equals(applicant2, candidate) => overrid bool Equals(Object obj) 호출

또한 op_Equality 및 op_Inequality 연산자를 오버로드해야한다. 
이렇게하면 동등성에 대한 모든 테스트가 일관된 결과를 반환하도록 보장한다.  

**다음은 Equals 메서드를 내부적으로 어떻게 올바르게 구현할 수 있는지를 설명하고 있다.**

1. 만약 obj 매개변수가 null로 전달되면 false를 반환하는데, 왜냐면 지금 호출되는
	Equals 메서드가 인스턴스 메서드이고 호출을 위해서는 this 포인터가 필요하며
	이 this 포인터가 인스턴스 메서드 호출을 위해서는 null로 지정될 수 없기 때문이다.  
	- public override bool Equals(object obj)
	- if (ReferenceEquals(null, obj)) return false;  

2. 만약 this와 obj 매개변수가 가리키는 대상이 동일하다면 true를 곧바로 반환해도 된다.
	이렇게 하여 모든 필드를 일일이 비교하는 일 없이 비교에 관한 코드의 성능을 향상 시킬 수 있다.

	- if (ReferenceEquals(this, obj)) return true;
  
3. 만약 this와 obj 매개변수가 가리키는 참조 대상의 타입이 전혀 다른 경우 간단히 false를
	반환하면 된다. 더 분명한 예를 들면, String 타입의 객체와 FileStream 타입의 객체를 
	비교할 수 없으므로 false를 반환할 수 밖에 없는 것과 같다.

	- if (obj.GetType() != this.GetType()) return false;
	- return Equals((T)obj);

4. 타입 내에 선언된 각 인스턴스 필드에 대해, 현재 객체와 상대 객체의 필드가 모드 일치하는지 
	확인을 한다. 하나라도 일치하지 않는다면, false를 반환하면 된다.

	- public bool Equals(Trade other)
	- string.Equals(Instrument, other.Instrument) && Bid == other.Bid && Offer == other.Offer;

5. 상위 클래스 타입에 대해 Equals 메서드를 호출하여 상위 클래스 타입에서 선언한 필드들에 대한
	나머지 남은 비교를 수행하도록 할 수 있다. 만약 상위 타입의 Equals 메서드에서 false를 
	반환한다면, 전체 결과는 flase로 반환되어야 하는 것이고, true를 반환했다면 전체 결과도
	true가 된다.

	```js
	public abstract class EntityBase : IEquatable<EntityBase>
	{
		public EntityBase() { }

		#region IEquatable<EntityBase> Members

		public bool Equals(EntityBase other)
		{
			//Generic implementation of equality using reflection on derived class instance.
			return true;
		}

		public override bool Equals(object obj)
		{
			return this.Equals(obj as EntityBase);
		}

		#endregion
	}

	public class Author : EntityBase
	{
		public Author() { }
	}

	public class Book : EntityBase
	{
		public Book() { }
	}
	```

Equals 메서드르 재정의할 때, 아마 다음에서 제시한 사항들을 구현하는 것을 검토할 수도 있을 것이다.

 `System.IEquatable<T>` 인터페이스의 Equals 메서드를 구현하는지의 여부:

이 제네릭 인터페이스를 통해서 타입 안정성을 보장판 Equals 메서드를 정의할 수 있다.

보통은 Object 매개변수를 받아들이는 Equals 메서드를 구현하고 내부적으로 타입 안정성에 부합하는 Equals 메서드로 호출을 넘기는 방식으로 구현할 수 있을 것이다.

= 연산자와 != 연산자 메서드를 재정의하기:

보통, 이 연산자 메서드들을 재정의하여 내부적으로 타입 안정성에 부합하는 Equals 메서드로 호출을 넘기는 방식으로 구현하려고 할 것이다.

```js
public static bool operator ==(Trade left, Trade right)
{
	return Equals(left, right); 
	// return left.Equals(rigth);
}

public static bool operator !=(Trade left, Trade right)
{
	return !Equals(left, right);
}
```

Equals 메서드를 재정의할 때 왜 GetHashCode 메서드도 같이 재정의해야 하는가?

System.Collections.HashTable 타입, System.Collections.Generic.Dictionary 타입을 
비롯한 다른 모든 컬렉션들에서는 두 개의 객체가 동일한 객체인지 살펴보기 위한 목적으로 
같은 해시 코드를 계산할 수 있는지를 살펴보기 때문이다. 

그래서 만약 Equals 메서드를 재정의했다면 GetHashCode 메서드도 같이 재정의하여 
여러분이 동일성을 판정하기 위하여 사용하는 알고리즘과 객체의 해시 코드를 계산하기 위하여 
사용하는 알고리즘이 일치하는 결과를 낼 수 있도록 만들어야만 한다.

해시 테이블과 같은 자료구조를 이용하여 개체를 관리할 때 적합한 키를 반환하는 메서드이다.
알고리즘에서 최소한 하나 이상의 인스턴스 필드를 활요해야만 한다.

```js
public override int GetHashCode()
{
		return (Code != null ? Code.GetHashCode() : 0);
}
```