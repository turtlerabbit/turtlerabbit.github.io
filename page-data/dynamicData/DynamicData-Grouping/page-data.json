{"componentChunkName":"component---src-templates-archive-post-js","path":"/dynamicData/DynamicData-Grouping/","result":{"data":{"mdx":{"id":"1bcb5f2d-9d91-561e-a9fd-3d8062166ff0","excerpt":"1. Group And Monitor PropertyChanges 속성의 첫 글자를 기준으로 그룹화하고 속성 변경시 그룹화 업데이트 2. Xamarin Forms Grouping Xamarin Forms를 사용한 맞춤형 그룹화 3. Custom Total Rows…","frontmatter":{"title":"Dynamic Data - Grouping","date":"January 12, 2021","tag":"DynamicData, Grouping, GroupWithImmutableState(), GroupOn(), ChangeKey()"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dynamic Data - Grouping\",\n  \"date\": \"2021-01-12 09\",\n  \"tag\": \"DynamicData, Grouping, GroupWithImmutableState(), GroupOn(), ChangeKey()\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null), mdx(\"h3\", null, \"1. Group And Monitor PropertyChanges\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uC18D\\uC131\\uC758 \\uCCAB \\uAE00\\uC790\\uB97C \\uAE30\\uC900\\uC73C\\uB85C \\uADF8\\uB8F9\\uD654\\uD558\\uACE0 \\uC18D\\uC131 \\uBCC0\\uACBD\\uC2DC \\uADF8\\uB8F9\\uD654 \\uC5C5\\uB370\\uC774\\uD2B8\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"private readonly IDisposable cleanUp;\\npublic IObservableList<SpeciesGroup> SpeciesByLetter { get; }\\n\\npublic GroupAndMonitorPropertyChanges(ISourceList<Species> sourceList)\\n{\\n    var shared = sourceList.Connect().Publish();\\n\\n    // fired when the name changes on any item in the source collection\\n    var nameChanged = shared.WhenValueChanged(species => species.Name);\\n\\n    // \\uCCAB \\uAE00\\uC790\\uB85C \\uADF8\\uB8F9\\uD654 \\uD558\\uACE0\\n    // \\uC120\\uD0DD\\uC801\\uC73C\\uB85C the nameChanged observable (as a unit)\\uC744 \\uC804\\uB2EC\\uD558\\uC5EC \\n    // \\uADF8\\uB8F9\\uD654\\uAC00 \\uADF8\\uB8F9\\uD654\\uB97C \\uB2E4\\uC2DC \\uC801\\uC6A9\\uD558\\uB3C4\\uB85D \\uC9C0\\uC2DC\\uD55C\\uB2E4.\\n    SpeciesByLetter = shared\\n        .GroupWithImmutableState(x => x.Name[0], nameChanged.Select(_ => Unit.Default))\\n        .Transform(grouping => new SpeciesGroup(grouping.Key, grouping.Items))\\n        .AsObservableList();\\n\\n    // \\uC5EC\\uAE30\\uC11C species\\uC758 \\uC774\\uB984\\uC774 \\uBCC0\\uACBD\\uB418\\uBA74 \\uD30C\\uC0DD \\uBAA9\\uB85D\\uC774 \\uC790\\uCCB4\\uC801\\uC73C\\uB85C \\uC720\\uC9C0\\uB41C\\uB2E4.\\n\\n    // Nothing happens until a Published source is connect\\n    var connected = shared.Connect();\\n\\n    this.cleanUp = new CompositeDisposable(sourceList, SpeciesByLetter, connected);\\n}\\n\\n#\\n\\nusing (var sourceList = new SourceList<Species>())\\nusing (var sut = new GroupAndMonitorPropertyChanges(sourceList))\\n{\\n// populate with initial data\\nvar initialData = new[]\\n{\\n    new Species(\\\"Ant\\\"),\\n    new Species(\\\"Ape\\\"),\\n    new Species(\\\"Bear\\\"),\\n    new Species(\\\"Boar\\\"),\\n    new Species(\\\"Cougar\\\")\\n};\\nsourceList.AddRange(initialData);\\n\\n// Check all data has loaded\\nvar items = sut.SpeciesByLetter.Items.SelectMany(g => g.Items);\\nforeach (var item in items)\\n{\\n    Console.WriteLine(item.Name);  // should all be Equivalent to initialData\\n}\\n\\nvar manualGrouping = sut.SpeciesByLetter.Items;\\nforeach (var item in manualGrouping)\\n{\\n    Console.WriteLine(item.Key);  // should be Equivalent to sourceList\\n}\\n\\nConsole.WriteLine(sut.SpeciesByLetter.Count);  // 3\\n\\n// \\uB370\\uC774\\uD130\\uC758 \\uCCAB \\uAE00\\uC790\\uB97C \\uBCC0\\uACBD\\uD558\\uBA74 \\uADF8\\uB8F9\\uC774 \\uBCC0\\uACBD\\uB41C\\uB2E4.\\ninitialData[0].Name = \\\"\\uD59At\\\";  // change the first letter\\nConsole.WriteLine(sut.SpeciesByLetter.Count);  // 4\\n\\n// assert everything\\nvar assertEverything = sut.SpeciesByLetter.Items;\\nforeach (var item in assertEverything)\\n{\\n    Console.WriteLine(item.Key);  // should be Equivalent to sourceList\\n}\\n\")), mdx(\"h1\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"DynamicData.ObservableListEx.GroupWithImmutableState();\\n// group selector factory\\uC5D0\\uC11C \\uBC18\\uD658 \\uD55C \\uAC12\\uC5D0 \\uB530\\uB77C \\uC18C\\uC2A4\\uB97C \\uADF8\\uB8F9\\uD654\\uD55C\\uB2E4.\\n// \\uAC01 \\uC5C5\\uB370\\uC774\\uD2B8\\uB294 \\uBCC0\\uACBD \\uBD88\\uAC00\\uB2A5\\uD55C \\uADF8\\uB8F9\\uD654\\uB97C \\uC0DD\\uC131\\uD55C\\uB2E4.\\n\\npublic static IObservable<IChangeSet<IGrouping<TObject, TGroupKey>>> \\n    GroupWithImmutableState<TObject, TGroupKey>(\\n          this IObservable<IChangeSet<TObject>> source, \\n          Func<TObject, TGroupKey> groupSelectorKey, \\n          IObservable<Unit>? regrouper = null) where TGroupKey : notnull;\\n\")), mdx(\"h1\", null), mdx(\"h3\", null, \"2. Xamarin Forms Grouping\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Xamarin Forms\\uB97C \\uC0AC\\uC6A9\\uD55C \\uB9DE\\uCDA4\\uD615 \\uADF8\\uB8F9\\uD654\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"private readonly IDisposable cleanUp;\\nprivate Func<Animal, bool> filter = a => true;\\npublic Func<Animal, bool> Filter\\n{\\n    get => this.filter;\\n    set => SetAndRaise(ref this.filter, value);\\n}\\npublic ReadOnlyObservableCollection<AnimalGroup> FamilyGroups { get; }\\n\\npublic XamarinFormsGrouping(IObservableList<Animal> source, \\n                            ISchedulerProvider schedulerProvider)\\n{\\n    /* Xamarin forms is a bit dumb \\n      * and cannot handle nested observable collections. \\n      * To cirumvent this limitation, \\n      * create a specialist observable collection with headers \\n      * and use dynamic data to manage it */\\n\\n    // create an observable predicate\\n    var observablePredicate = this\\n        .WhenValueChanged(@this => @this.Filter)\\n        .ObserveOn(schedulerProvider.Background);\\n\\n    this.cleanUp = source\\n        .Connect()\\n        .Filter(observablePredicate)  // Apply filter dynamically                \\n        .GroupOn(arg => arg.Family)  // create a dynamic group\\n        .Transform(grouping => new AnimalGroup(grouping, schedulerProvider)) \\n                       //transform into a specialised observable collection\\n        .Sort(SortExpressionComparer<AnimalGroup>.Ascending(a => a.Family))\\n        .ObserveOn(schedulerProvider.MainThread)\\n        .Bind(out var animals)\\n        .DisposeMany() //use DisposeMany() because the grouping is disposable\\n        .Subscribe();\\n\\n    FamilyGroups = animals;\\n}\\n\\n#\\n\\nvar items = new[]\\n{\\n    new Animal(\\\"Holly\\\", \\\"Cat\\\", AnimalFamily.Mammal),\\n    new Animal(\\\"Rover\\\", \\\"Dog\\\", AnimalFamily.Mammal),\\n    new Animal(\\\"Rex\\\", \\\"Dog\\\", AnimalFamily.Mammal),\\n    new Animal(\\\"Whiskers\\\", \\\"Cat\\\", AnimalFamily.Mammal),\\n    new Animal(\\\"Nemo\\\", \\\"Fish\\\", AnimalFamily.Fish),\\n    new Animal(\\\"Moby Dick\\\", \\\"Whale\\\", AnimalFamily.Mammal),\\n    new Animal(\\\"Fred\\\", \\\"Frog\\\", AnimalFamily.Amphibian),\\n    new Animal(\\\"Isaac\\\", \\\"Next\\\", AnimalFamily.Amphibian),\\n    new Animal(\\\"Sam\\\", \\\"Snake\\\", AnimalFamily.Reptile),\\n    new Animal(\\\"Sharon\\\", \\\"Red Backed Shrike\\\", AnimalFamily.Bird),\\n};\\n\\nvar schedulerProvider = new TestSchedulerProvider();\\n\\nusing (var sourceList = new SourceList<Animal>())\\nusing (var sut = new XamarinFormsGrouping(sourceList, schedulerProvider))\\n{\\n    // populate with initial data\\n    sourceList.AddRange(items);\\n\\n    Console.WriteLine(sut.FamilyGroups.Count);  // 5\\n    Console.WriteLine(\\n      sut.FamilyGroups.Single(group => group.Family == AnimalFamily.Mammal).Count); // 5\\n    Console.WriteLine(\\n      sut.FamilyGroups.Single(group => group.Family == AnimalFamily.Fish).Count);  // 1\\n\\n    // apply a filter\\n    sut.Filter = a => a.Type == \\\"Dog\\\" || a.Type == \\\"Fish\\\";\\n\\n    Console.WriteLine(sut.FamilyGroups.Count);  // 2\\n    Console.WriteLine(\\n      sut.FamilyGroups.Single(group => group.Family == AnimalFamily.Mammal).Count); // 5\\n    Console.WriteLine(\\n      sut.FamilyGroups.Single(group => group.Family == AnimalFamily.Fish).Count);  // 1\\n\\n    // clear list and all groupings are gone\\n    sourceList.Clear();\\n    Console.WriteLine(sut.FamilyGroups.Count);  // 0\\n}\\n\")), mdx(\"h1\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"DynamicData.ObservableListEx.GroupOn();\\n// Groups the source on the value returned by group selector factory.\\n// The groupings contains an inner observable list.\\n\\npublic static IObservable<IChangeSet<IGroup<TObject, TGroup>>> \\n    GroupOn<TObject, TGroup>(this IObservable<IChangeSet<TObject>> source, \\n          Func<TObject, TGroup> groupSelector, IObservable<Unit>? regrouper = null) \\n              where TGroup : notnull;\\n\")), mdx(\"h1\", null), mdx(\"h3\", null, \"3. Custom Total Rows\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uC0AC\\uC6A9\\uC790 \\uC9C0\\uC815 \\uC9D1\\uACC4\\uC5D0 \\uADF8\\uB8F9\\uD654\\uB97C \\uC0AC\\uC6A9\\uD560 \\uC218\\uC788\\uB294 \\uBC29\\uBC95 \\uC124\\uBA85\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uC774 \\uAE30\\uC220\\uC740 \\uB3D9\\uC801 \\uB204\\uC801 \\uD569\\uACC4\\uB85C \\uADF8\\uB9AC\\uB4DC \\uB370\\uC774\\uD130\\uB97C \\uB9CC\\uB4DC\\uB294 \\uB370 \\uC0AC\\uC6A9\\uD560 \\uC218 \\uC788\\uB2E4.\", mdx(\"br\", {\n    parentName: \"li\"\n  }), \"[In production systems I also include the ability to have total row expanders - perhaps an example could follow another time]\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"private readonly IDisposable cleanUp;\\npublic IObservableCache<TradeProxy, AggregationKey> AggregatedData { get; }\\n\\npublic CustomTotalRows(IObservableCache<Trade, int> source)\\n{\\n    // 1. create a trade proxy which enriches the trade with an aggregation id.\\n    var ticker = source\\n        .Connect()\\n        .ChangeKey(proxy => \\n            new AggregationKey(AggregationType.Item, proxy.Id.ToString()))\\n        .Transform((trade, key) => new TradeProxy(trade, key));\\n\\n    // 2. create grouping based on each ticker\\n    var tickerTotals = source\\n        .Connect()\\n        .GroupWithImmutableState(trade => \\n            new AggregationKey(AggregationType.SubTotal, trade.Ticker))\\n        .Transform(grouping => new TradeProxy(grouping.Items.ToArray(), grouping.Key));\\n\\n    // 3. create grouping of 1 so we can create grand total row\\n    var overallTotal = source\\n        .Connect()\\n        .GroupWithImmutableState(trade => \\n            new AggregationKey(AggregationType.GrandTotal, \\\"All\\\"))\\n        .Transform(grouping => new TradeProxy(grouping.Items.ToArray(), grouping.Key));\\n\\n    // 4. join all togather so results are in a single cache\\n    AggregatedData = ticker\\n        .Or(overallTotal)\\n        .Or(tickerTotals)\\n        .AsObservableCache();\\n\\n    this.cleanUp = AggregatedData;\\n}\\n\\n#\\n\\nconst string USD = \\\"USD\\\";\\nconst string GBP = \\\"GBP\\\";\\nconst string CHF = \\\"CHF\\\";\\n\\nvar items = new[]\\n{\\n    new Trade(1, GBP, 100),\\n    new Trade(2, GBP, 200),\\n    new Trade(3, GBP, 100),\\n    new Trade(4, GBP, 200),\\n    new Trade(5, USD, 100),\\n    new Trade(6, USD, 200),\\n    new Trade(7, CHF, 100),\\n    new Trade(8, CHF, 200),\\n};\\n\\nusing (var source = new SourceCache<Trade, int>(t => t.Id))\\nusing (var sut = new CustomTotalRows(source))\\n{\\n    source.AddOrUpdate(items);\\n\\n    // should be 1 grand total row, 3 sub total rows, 8 rows\\n    Console.WriteLine(sut.AggregatedData.Count);  // 12\\n    Console.WriteLine(\\n      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.GrandTotal));\\n      // 1\\n    Console.WriteLine(\\n      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.SubTotal));\\n      // 3\\n    Console.WriteLine(\\n      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.Item)); \\n      // 8\\n    foreach (var item in sut.AggregatedData.Items.OrderBy(tp => tp.Ticker))\\n    {\\n        Console.WriteLine(item);  \\n        // Should all be equivalent to CustomTotalRowsExpectation(source)\\n    }\\n\\n    //remove all gbp rows. should be 1 grand total row, 2 sub total rows, 4 rows\\n    source.RemoveKeys(new[] { 1, 2, 3, 4 });\\n    Console.WriteLine(\\n      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.GrandTotal));\\n      // 1\\n    Console.WriteLine(\\n      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.SubTotal));\\n      // 2\\n    Console.WriteLine(\\n      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.Item)); \\n      // 4\\n    foreach (var item in sut.AggregatedData.Items.OrderBy(tp => tp.Ticker))\\n    {\\n        Console.WriteLine(item);  \\n        // Should all be equivalent to CustomTotalRowsExpectation(source)\\n    }\\n\\n    // add a previously unseen ticker - a new sub total row should have been added\\n    source.AddOrUpdate(new Trade(100, \\\"TRY\\\", 2000));\\n    Console.WriteLine(\\n      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.GrandTotal)); \\n      // 1\\n    Console.WriteLine(\\n      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.SubTotal)); \\n      // 3\\n    Console.WriteLine(\\n      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.Item)); \\n      // 5\\n    foreach (var item in sut.AggregatedData.Items.OrderBy(tp => tp.Ticker))\\n    {\\n        Console.WriteLine(item);  \\n        // Should all be equivalent to CustomTotalRowsExpectation(source)\\n    }\\n}\\n\")), mdx(\"h1\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"DynamicData.ObservableListEx.ChangeKey();\\n// Changes the primary key.\\n\\npublic static IObservable<IChangeSet<TObject, TDestinationKey>> \\n    ChangeKey<TObject, TSourceKey, TDestinationKey>(this IObservable<IChangeSet<TObject, \\n        TSourceKey>> source, Func<TObject, TDestinationKey> keySelector)\\n            where TSourceKey : notnull\\n            where TDestinationKey : notnull;\\n\")), mdx(\"h1\", null), mdx(\"h3\", null, \"4. Custom Total Rows Expectation\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"IEnumerable<TradeProxy> CustomTotalRowsExpectation(SourceCache<Trade, int> source)\\n{\\n    yield return new TradeProxy(\\n        source.Items.ToArray(), \\n        new AggregationKey(AggregationType.GrandTotal, \\\"All\\\"));\\n\\n    foreach (var proxy in source.Items\\n        .GroupBy(trade => new AggregationKey(AggregationType.Item, trade.Id.ToString()))\\n        .Select(g => new TradeProxy(g.ToArray(), g.Key)))\\n    {\\n        yield return proxy;\\n    }\\n\\n    foreach (var proxy in source.Items\\n        .GroupBy(trade => new AggregationKey(AggregationType.SubTotal, trade.Ticker))\\n        .Select(g => new TradeProxy(g.ToArray(), g.Key)))\\n    {\\n        yield return proxy;\\n    }\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"slug":"/dynamicData/DynamicData-Grouping/","previous":{"id":"240cce73-7b1b-58f2-9ab8-0828aa52492a","fields":{"slug":"/dynamicData/DynamicData-Filtering/"},"frontmatter":{"title":"Dynamic Data - Filtering"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dynamic Data - Filtering\",\n  \"date\": \"2021-01-12 08\",\n  \"tag\": \"DynamicData, Filtering, IObservableList<T>, AsObservableList(), SourceList<T>, FilterOnProperty()\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null), mdx(\"h3\", null, \"1. Static Filter\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uAE30\\uBCF8 \\uBAA9\\uB85D\\uC774 \\uCD94\\uAC00 \\uB610\\uB294 \\uC0AD\\uC81C\\uB97C \\uC218\\uC2E0 \\uD560 \\uB54C\\uB9CC Mammals\\uBCC4\\uB85C \\uC790\\uB3D9 \\uD544\\uD130\\uB9C1\\uB41C\\uB2E4.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"public StaticFilter(IObservableList<Animal> source)\\n{\\n    // \\uC774 \\uBAA9\\uB85D\\uC740 \\uAE30\\uBCF8 \\uBAA9\\uB85D\\uC774 \\uCD94\\uAC00 \\uB610\\uB294 \\uC81C\\uAC70\\uB97C \\uC218\\uC2E0 \\uD560 \\uB54C\\uB9CC\\n    // Mammals\\uBCC4\\uB85C \\uC790\\uB3D9 \\uD544\\uD130\\uB9C1\\uB41C\\uB2E4.\\n    Mammals = source\\n        .Connect()\\n        .Filter(animal => animal.Family == AnimalFamily.Mammal)\\n        .AsObservableList();\\n\\n    this.cleanUp = Mammals;\\n}\\n\\n#\\n\\nusing (var sourceList = new SourceList<Animal>())\\nusing (var sut = new StaticFilter(sourceList))\\n{\\n    sourceList.AddRange(items);\\n\\n    // items.Where(a=>a.Family == AnimalFamily.Mammal)\\n    Console.WriteLine(sut.Mammals.Items);\\n    Console.WriteLine(sut.Mammals.Count);  // 5\\n\\n    // add a new mammal to show it is included in the result set\\n    sourceList.Add(new Animal(\\\"Bob\\\", \\\"Human\\\", AnimalFamily.Mammal));\\n    Console.WriteLine(sut.Mammals.Count);  // 6\\n\\n    // remove the first 4 items which will leave 2 mammals\\n    sourceList.RemoveRange(0, 4);\\n    Console.WriteLine(sut.Mammals.Count); // 2\\n}\\n\")), mdx(\"h1\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// DynamicData.IObservableList<T>\\n// A readonly observable list, \\n// providing observable methods as well as data access methods.\\n\\npublic interface IObservableList<T> : IDisposable\\n{\\n    // Gets the count.\\n    int Count { get; }\\n\\n    // Gets observe the count changes, starting with the initial items count.\\n    IObservable<int> CountChanged { get; }\\n\\n    // Gets items enumerable.\\n    IEnumerable<T> Items { get; }\\n\\n    // Connect to the observable list \\n    // and observe any changes starting with the list's initial items.\\n    IObservable<IChangeSet<T>> Connect(Func<T, bool>? predicate = null);\\n\\n    // Connect to the observable list \\n    // and observe any changes before they are applied to the list. \\n    // Unlike Connect(), the returned observable is not prepended with\\n    // the lists initial items.\\n    IObservable<IChangeSet<T>> Preview(Func<T, bool>? predicate = null);\\n}\\n\")), mdx(\"h1\", null), mdx(\"h1\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// DynamicData.SourceList<T> : ISourceList<T>, IObservableList<T>, IDisposable\\n\\npublic sealed class SourceList<T> : ISourceList<T>, IObservableList<T>, IDisposable\\n{\\n    public SourceList(IObservable<IChangeSet<T>>? source = null);\\n\\n    public int Count { get; }\\n    public IObservable<int> CountChanged { get; }\\n    public IEnumerable<T> Items { get; }\\n\\n    public IObservable<IChangeSet<T>> Connect(Func<T, bool>? predicate = null);\\n    public void Dispose();\\n    public void Edit(Action<IExtendedList<T>> updateAction);\\n    public IObservable<IChangeSet<T>> Preview(Func<T, bool>? predicate = null);\\n}\\n\\n// \\uC77D\\uAE30\\uC804\\uC6A9\\uC73C\\uB85C \\uD30C\\uC0DD \\uCEEC\\uB809\\uC158\\uC744 \\uB9CC\\uB4E4\\uC5B4 \\uB178\\uCD9C\\n// IObservable<IChangeSet<T>>.AsObservableList()\\n// return type : IObservableList<T>\\n\\n// IObservableList<T>.Connect()\\n// return type : IObservable<IChangeSet<T>>\\n\")), mdx(\"h1\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"DynamicData.ObservableListEx.AsObservableList();\\n// Converts the source observable to an read only observable list.\\n\\npublic static IObservableList<T> \\n        AsObservableList<T>(this ISourceList<T> source); \\n\\npublic static IObservableList<T> \\n        AsObservableList<T>(this IObservable<IChangeSet<T>> source);\\n\")), mdx(\"h1\", null), mdx(\"h3\", null, \"2. Dynamic Filter\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Create list which automatically filters when AnimalFilter changes\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"public IObservableList<Animal> Filtered { get; }\\n\\npublic DynamicFilter(IObservableList<Animal> source, ISchedulerProvider schedulerProvider)\\n{\\n    // AnimalFilter \\uC18D\\uC131\\uC774 \\uBCC0\\uACBD \\uB420 \\uB54C\\uB9C8\\uB2E4 new predicate\\uB97C \\uC0DD\\uC131\\uD558\\uB294 observable\\uC744 \\uC0DD\\uC131\\uD55C\\uB2E4.\\n    var dynamicFilter = this\\n        .WhenValueChanged(@this => @this.AnimalFilter)\\n        .Throttle(TimeSpan.FromMilliseconds(250), schedulerProvider.Background)\\n        //throttle to prevent constant filtering (i.e. when users type)\\n        .Select(CreatePredicate);\\n\\n    // Create list which automatically filters when AnimalFilter changes\\n    Filtered = source\\n        .Connect()\\n        .Filter(dynamicFilter)\\n        // dynamicfilter\\uB294 \\uAD00\\uCC30 \\uAC00\\uB2A5\\uD55C \\uBAA8\\uB4E0 \\uC220\\uC5B4\\uB97C \\uD5C8\\uC6A9 \\uD560 \\uC218 \\uC788\\uB2E4.\\n        // (\\uC989, \\uC18D\\uC131\\uC744 \\uAE30\\uBC18\\uC73C\\uB85C\\uD558\\uC9C0 \\uC54A\\uC544\\uB3C4 \\uB428).\\n        .AsObservableList();\\n\\n    this.cleanUp = Filtered;\\n}\\n\\nprivate Func<Animal, bool> CreatePredicate(string text)\\n{\\n    if (text == null || text.Length < 3)\\n    {\\n        return animal => true;\\n    }\\n\\n    // the more fields which are filtered on the slower it takes for the filter to apply \\n    // by generally I have never found checking a predicate to be particularly slow \\n    return animal => animal.Name.Contains(text)\\n                        || animal.Type.Contains(text)\\n                        || animal.Family.ToString().Contains(text);\\n}\\n\\n#\\n\\nvar schedulerProvider = new TestSchedulerProvider();\\nusing (var sourceList = new SourceList<Animal>())\\nusing (var sut = new DynamicFilter(sourceList, schedulerProvider))\\n{\\n    // add items\\n    sourceList.AddRange(items);\\n\\n    Console.WriteLine(sut.Filtered.Count);\\n\\n    // set a filter\\n    sut.AnimalFilter = \\\"Dog\\\";  // items.Where(a=>a.Type == \\\"Dog\\\")\\n\\n    Console.WriteLine(sut.Filtered.Count);  // 2\\n\\n    // add a new dog to show it is included in the result set\\n    sourceList.Add(new Animal(\\\"George\\\", \\\"Dog\\\", AnimalFamily.Mammal));\\n\\n    Console.WriteLine(sut.Filtered.Count);  // 3\\n\\n    // add a new bird to show it is included in the result set\\n    sourceList.Add(new Animal(\\\"Peter\\\", \\\"Parrot\\\", AnimalFamily.Bird));\\n\\n    Console.WriteLine(sut.Filtered.Count);  // 3\\n\\n    // My additions...\\n    sut.AnimalFilter = \\\"Frog\\\"; // items.Where(a => a.Type == \\\"Frog\\\")\\n\\n    Console.WriteLine(sut.Filtered.Count);  // 1\\n}\\n\")), mdx(\"h1\", null), mdx(\"h3\", null, \"3. Property Filter\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uC790\\uB3D9\\uC73C\\uB85C \\uD544\\uD130\\uB9C1\\uD558\\uB294 \\uBAA9\\uB85D \\uB9CC\\uB4E4\\uAE30\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"public class PropertyFilter : AbstractNotifyPropertyChanged, IDisposable\\n{\\n    private readonly IDisposable cleanUp;\\n    public IObservableList<Animal> Filtered { get; }\\n\\n    public PropertyFilter(IObservableList<Animal> source, \\n                            ISchedulerProvider schedulerProvider)\\n    {\\n        /*\\n        *  Create list which automatically filters : \\n        *  \\n        *  a) \\uAE30\\uBCF8 \\uBAA9\\uB85D\\uC774 \\uBCC0\\uACBD \\uB420 \\uB54C\\n        *  b) IncludeInResults \\uC18D\\uC131\\uC774 \\uBCC0\\uACBD\\uB418\\uB294 \\uACBD\\uC6B0\\n        *  c) \\uC8FC\\uC758 : IncludeInResults \\uC18D\\uC131\\uC774 \\uBE60\\uB978 sucession\\uC73C\\uB85C multiple animals\\uC5D0\\uC11C \\n        *            \\uBCC0\\uACBD \\uB420 \\uC218 \\uC788\\uB294 \\uACBD\\uC6B0 throttle\\uB97C  \\uCD94\\uAC00\\uD55C\\uB2E4.\\n        *            (\\uC989, \\uC18C\\uD488\\uC774 \\uBCC0\\uACBD \\uB420 \\uB54C\\uB9C8\\uB2E4 \\uD544\\uD130\\uAC00 \\uC7AC\\uD3C9\\uAC00\\uB418\\uC5B4 \\uC7A0\\uC7AC\\uC801\\uC73C\\uB85C \\n        *                 \\uC5C5\\uB370\\uC774\\uD2B8\\uAC00 \\uAE09\\uC99D \\uD560 \\uC218 \\uC788\\uB2E4. \\uC18D\\uB3C4\\uB97C \\uB2A6\\uCD94\\uB294 \\uAC83\\uC774 \\uC88B\\uB2E4.)\\n        */\\n\\n        Filtered = source\\n            .Connect()\\n            .FilterOnProperty(\\n                animal => animal.IncludeInResults,\\n                animal => animal.IncludeInResults,\\n                TimeSpan.FromMilliseconds(250),\\n                schedulerProvider.MainThread)\\n            .AsObservableList();\\n    }\\n\\n    public void Dispose()\\n    {\\n        this.cleanUp.Dispose();\\n    }\\n}\\n\\n#\\n\\nvar schedulerProvider = new TestSchedulerProvider();\\nusing (var sourceList = new SourceList<Animal>())\\nusing (var sut = new PropertyFilter(sourceList, schedulerProvider))\\n{\\n    // add items\\n    sourceList.AddRange(items);\\n    Console.WriteLine(sut.Filtered.Count);  // 0\\n\\n    // set to true to include in the result set\\n    items[1].IncludeInResults = true;\\n    items[2].IncludeInResults = true;\\n    items[3].IncludeInResults = true;\\n\\n    Console.WriteLine(sut.Filtered.Items);  // itmes[1], items[2], items[3]\\n}\\n\")), mdx(\"h1\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"DynamicData.ObservableListEx.FilterOnProperty();\\n// buffer\\uC758 \\uC791\\uC5C5 \\uACB0\\uACFC\\uB97C change set\\uB85C \\uBCC0\\uD658\\uD55C\\uB2E4.\\n\\npublic static IObservable<IChangeSet<TObject>> \\n    FilterOnProperty<TObject, TProperty>(this IObservable<IChangeSet<TObject>> source, \\n        Expression<Func<TObject, TProperty>> propertySelector, \\n        Func<TObject, bool> predicate, TimeSpan? propertyChangedThrottle = null, \\n        IScheduler? scheduler = null) where TObject : INotifyPropertyChang\\n\\n\")), mdx(\"h1\", null), mdx(\"h3\", null, \"4. External Source Filter\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uB2E4\\uB978 \\uD544\\uD130\\uC758 \\uACB0\\uACFC\\uC5D0\\uC11C \\uD544\\uD130\\uB9C1 \\uB41C \\uBAA9\\uB85D \\uB9CC\\uB4E4\\uAE30\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"public class ExternalSourceFilter : AbstractNotifyPropertyChanged, IDisposable\\n{\\n    private readonly IDisposable cleanUp;\\n    public IObservableList<Animal> Filtered { get; }\\n\\n    public ExternalSourceFilter(IObservableList<Animal> source, \\n                                    IObservableList<AnimalFamily> families)\\n    {\\n        /*\\n         *  Create list which is filtered from the result of another filter\\n         */\\n\\n        var familyFilter = families\\n            .Connect()\\n            .ToCollection()\\n            .Select(items =>\\n            {\\n                bool Predicate(Animal animal) => items.Contains(animal.Family);\\n                return (Func<Animal, bool>)Predicate;\\n            });\\n\\n        Filtered = source\\n            .Connect()\\n            .Filter(familyFilter)\\n            .AsObservableList();\\n\\n        this.cleanUp = Filtered;\\n    }\\n\\n    public void Dispose()\\n    {\\n        this.cleanUp.Dispose();\\n    }\\n}\\n\\n#\\n\\nusing (var sourceList = new SourceList<Animal>())\\nusing (var families = new SourceList<AnimalFamily>())\\nusing (var sut = new ExternalSourceFilter(sourceList, families))\\n{\\n    // add items to source\\n    sourceList.AddRange(items);\\n    Console.WriteLine(sut.Filtered.Count);  // 0\\n\\n    families.AddRange(new []{ AnimalFamily.Amphibian, AnimalFamily.Bird });\\n    Console.WriteLine(sut.Filtered.Items);  \\n    //  items.Where(a => a.Family == AnimalFamily.Amphibian \\n    //  || a.Family==AnimalFamily.Bird)\\n\\n    families.Remove(AnimalFamily.Amphibian);\\n    Console.WriteLine(sut.Filtered.Items);  \\n    //  Where(a => a.Family == AnimalFamily.Bird)\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"next":{"id":"0a911901-ba7f-535f-8612-69289a1cb756","fields":{"slug":"/dynamicData/DynamicData-Testing/"},"frontmatter":{"title":"Dynamic Data - Testing"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dynamic Data - Testing\",\n  \"date\": \"2021-01-12 10\",\n  \"tag\": \"DynamicData,\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null), mdx(\"h3\", null, \"1. ViewModel\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"public ViewModel(IDataProvider dataProvider, ISchedulerProvider schedulerProvider)\\n{\\n    var paused = this.WhenValueChanged(vm => vm.IsPaused);\\n\\n    var dataLoader = dataProvider.ItemCache\\n        .Connect()\\n        .Transform(CreateItemViewModel)\\n        .BatchIf(paused, schedulerProvider.Background) // \\uC77C\\uC2DC\\uC911\\uC9C0 + \\uBC31\\uADF8\\uB77C\\uC6B4\\uB4DC \\uD14C\\uC2A4\\uD2B8\\n        .Sort(SortExpressionComparer<ItemsViewModel>.Descending(i => i.Item.Id))\\n        .Bind(out var bindingData)\\n        .Subscribe();\\n\\n    BindingData = bindingData;\\n\\n    var counter = dataProvider.ItemCache.CountChanged\\n        .Subscribe(i => ShowEmptyView = i == 0);\\n\\n    this.cleanUp = new CompositeDisposable(dataLoader, counter);\\n}\\n\\nprivate ItemsViewModel CreateItemViewModel(Item item)\\n{\\n    return new ItemsViewModel(item);\\n}\\n\\n#\\n\\nvar schedulerProvider = new TestSchedulerProvider();\\nusing (var testData = new DataProviderStub())\\nusing (var sut = new ViewModel(testData, schedulerProvider))\\n{\\n    // Act\\n    var items = Enumerable\\n        .Range(1, 10)\\n        .Select(i => new Item(i))\\n        .ToArray();\\n    testData.Data.AddOrUpdate(items);\\n\\n    // 1. Check count of data\\n    Console.WriteLine(sut.BindingData.Count); // 10\\n\\n    // 2. Check Transform and Sort\\n    var expectedData = items\\n        .Select(i => new ItemsViewModel(i))\\n        .OrderByDescending(vm => vm.Item.Id);\\n    foreach (var item in expectedData)\\n    {\\n        Console.WriteLine(item.Item.Id);  // 10 ~ 1\\n    }\\n}\\n\")), mdx(\"h1\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"DynamicData.ObservableCacheEx.BatchIf();\\n// pause signal\\uC774 \\uC218\\uC2E0 \\uB41C \\uACBD\\uC6B0 \\uAE30\\uBCF8 \\uC5C5\\uB370\\uC774\\uD2B8\\uB97C \\uC77C\\uAD04 \\uCC98\\uB9AC\\uD55C\\uB2E4.\\n// (i.e when the buffer selector return true)\\n// resume signal\\uC774 \\uC218\\uC2E0 \\uB418\\uBA74 \\uC77C\\uAD04 \\uC5C5\\uB370\\uC774\\uD2B8\\uAC00 \\uC2E4\\uD589\\uB41C\\uB2E4.\\n\\npublic static IObservable<IChangeSet<TObject, TKey>> \\n    BatchIf<TObject, TKey>(this IObservable<IChangeSet<TObject, TKey>> source, \\n        IObservable<bool> pauseIfTrueSelector, IScheduler? scheduler = null) \\n            where TKey : notnull;\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}}},"staticQueryHashes":[]}