{"componentChunkName":"component---src-templates-archive-post-js","path":"/dynamicData/DynamicData-Sorting/","result":{"data":{"mdx":{"id":"db59bc31-04a3-5f24-8473-b44afa00e3fc","excerpt":"1. Custom Binding 재설정 임계값(reset threshold)을 동적으로 제어될 수 있는지에 대한 확인. 2. Change Comparer IObservable <IComparer<T>> 를 연산자 Sort()에 전달하여 정렬(sorting…","frontmatter":{"title":"Dynamic Data - Sorting","date":"January 12, 2021","tag":"DynamicData, Sort, Threshold, Ascending, Decending, SortExpressionComparer, AsObservableList(), ISourceList<T>, IObservableList<T>"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dynamic Data - Sorting\",\n  \"date\": \"2021-01-12 07\",\n  \"tag\": \"DynamicData, Sort, Threshold, Ascending, Decending, SortExpressionComparer, AsObservableList(), ISourceList<T>, IObservableList<T>\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null), mdx(\"h3\", null, \"1. Custom Binding\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uC7AC\\uC124\\uC815 \\uC784\\uACC4\\uAC12(reset threshold)\\uC744 \\uB3D9\\uC801\\uC73C\\uB85C \\uC81C\\uC5B4\\uB420 \\uC218 \\uC788\\uB294\\uC9C0\\uC5D0 \\uB300\\uD55C \\uD655\\uC778.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"/*\\n    Sometimes the default binding does not behave exactly as you want.\\n    Using VariableThresholdObservableCollectionAdaptor is an example of \\n    how you can inject your own behaviour.\\n*/\\n\\npublic CustomBinding(IObservableCache<Animal, string> source)\\n{\\n    Threshold = 5;\\n\\n    this.cleanUp = source\\n        .Connect()\\n        .Sort(SortExpressionComparer<Animal>.Ascending(a => a.Name))\\n        .Bind(\\n          out var data, \\n          adaptor: new VariableThresholdObservableCollectionAdaptor<Animal, string>(\\n            () => Threshold))\\n        .Subscribe();\\n\\n    Data = data;\\n}\\n\\n#\\n\\nAnimal[] items = new[]\\n    {\\n        new Animal(\\\"Holly\\\", \\\"Cat\\\", AnimalFamily.Mammal),\\n        new Animal(\\\"Rover\\\", \\\"Dog\\\", AnimalFamily.Mammal),\\n        new Animal(\\\"Rex\\\", \\\"Dog\\\", AnimalFamily.Mammal),\\n        new Animal(\\\"Whiskers\\\", \\\"Cat\\\", AnimalFamily.Mammal),\\n        new Animal(\\\"Nemo\\\", \\\"Fish\\\", AnimalFamily.Fish),\\n        new Animal(\\\"Moby Dick\\\", \\\"Whale\\\", AnimalFamily.Mammal),\\n        new Animal(\\\"Fred\\\", \\\"Frog\\\", AnimalFamily.Amphibian),\\n        new Animal(\\\"Isaac\\\", \\\"Next\\\", AnimalFamily.Amphibian),\\n        new Animal(\\\"Sam\\\", \\\"Snake\\\", AnimalFamily.Reptile),\\n        new Animal(\\\"Sharon\\\", \\\"Red Backed Shrike\\\", AnimalFamily.Bird),\\n    };\\n\\nusing (var sourceCache = new SourceCache<Animal, string>(a => a.Name))\\nusing (var sut = new CustomBinding(sourceCache))\\n{\\n    int resetCount = 0;\\n    (sut.Data as INotifyCollectionChanged).CollectionChanged += (_, e) =>\\n    {\\n        if (e.Action == NotifyCollectionChangedAction.Reset)\\n        {\\n            resetCount++;\\n        }\\n    };\\n\\n    sut.Threshold = 20;\\n    sourceCache.AddOrUpdate(items);\\n    Console.WriteLine(resetCount);  // 0\\n\\n    sut.Threshold = 9;  // itmes.Count > sut.Threshold { resetCount++ }\\n                        // \\uC218\\uC6A9 \\uC784\\uACC4\\uCE58\\uAC00 \\uCEEC\\uB809\\uC158\\uC758 \\uCE74\\uC6B4\\uD2B8\\uBCF4\\uB2E4 \\uC791\\uB2E4.\\n                        // \\uADF8\\uB798\\uC11C \\uCEEC\\uB809\\uC158 \\uCCB4\\uC778\\uC9C0\\uAC00 \\uBC1C\\uC0DD\\uD55C\\uB2E4.\\n    sourceCache.AddOrUpdate(items);\\n    Console.WriteLine(resetCount);  // 1\\n\\n    sut.Threshold = 20;\\n    sourceCache.AddOrUpdate(items);\\n    Console.WriteLine(resetCount);  // 1\\n\\n    sut.Threshold = 5;  // itmes.Count > sut.Threshold { resetCount++ }\\n    sourceCache.AddOrUpdate(items);\\n    Console.WriteLine(resetCount);  // 2\\n}\\n\")), mdx(\"h1\", null), mdx(\"h3\", null, \"2. Change Comparer\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"IObservable\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"<IComparer<T>>\"), \"\\uB97C \\uC5F0\\uC0B0\\uC790 Sort()\\uC5D0 \\uC804\\uB2EC\\uD558\\uC5EC \\uC815\\uB82C(sorting)\\uC744 \\uC804\\uD658\\uD55C\\uB2E4.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uB3D9\\uC77C\\uD55C \\uAC1C\\uB150\\uC774 ObservableCache\\uC5D0\\uB3C4 \\uC801\\uC6A9\\uB41C\\uB2E4.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"public ChangeComparereOption Option\\n{\\n    get => this.option;\\n    set => SetAndRaise(ref this.option, value);\\n}\\npublic IObservableList<int> DataSource { get; }\\n\\npublic ChangeComparer(IObservableList<int> source)\\n{\\n    IObservable<SortExpressionComparer<int>> optionChanged = this\\n        .WhenValueChanged(@this => @this.Option)\\n        .Select(opt => opt == ChangeComparereOption.Ascending\\n            ? SortExpressionComparer<int>.Ascending(i => i)\\n            : SortExpressionComparer<int>.Descending(i => i));\\n\\n    // create a sorted observable list\\n    DataSource = source\\n        .Connect()\\n        .Sort(optionChanged)\\n        .AsObservableList();\\n\\n    this.cleanUp = DataSource;\\n}\\n\\n#\\n\\nusing (var input = new SourceList<int>())\\nusing (var sut = new ChangeComparer(input))\\n{\\n    input.AddRange(randomValues);\\n    Console.WriteLine(sut.DataSource.Items);  // Should all be equivalent to ascending\\n\\n    sut.Option = ChangeComparereOption.Descending;\\n    Console.WriteLine(sut.DataSource.Items);  // Should all be equivalent to descending\\n\\n    sut.Option = ChangeComparereOption.Ascending;\\n    Console.WriteLine(sut.DataSource.Items);  // Should all be equivalent to ascending\\n}\\n\")), mdx(\"h1\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// DynamicData.SourceList<T> : ISourceList<T>, IObservableList<T>, IDisposable\\n\\npublic sealed class SourceList<T> : ISourceList<T>, IObservableList<T>, IDisposable\\n{\\n    public SourceList(IObservable<IChangeSet<T>>? source = null);\\n\\n    public int Count { get; }\\n    public IObservable<int> CountChanged { get; }\\n    public IEnumerable<T> Items { get; }\\n\\n    public IObservable<IChangeSet<T>> Connect(Func<T, bool>? predicate = null);\\n    public void Dispose();\\n    public void Edit(Action<IExtendedList<T>> updateAction);\\n    public IObservable<IChangeSet<T>> Preview(Func<T, bool>? predicate = null);\\n}\\n\\n// \\uC77D\\uAE30\\uC804\\uC6A9\\uC73C\\uB85C \\uD30C\\uC0DD \\uCEEC\\uB809\\uC158\\uC744 \\uB9CC\\uB4E4\\uC5B4 \\uB178\\uCD9C\\n// IObservable<IChangeSet<T>>.AsObservableList()\\n// return type : IObservableList<T>\\n\\n// IObservableList<T>.Connect()\\n// return type : IObservable<IChangeSet<T>>\\n\")), mdx(\"h1\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// DynamicData.IObservableList<T>\\n// A readonly observable list, \\n// providing observable methods as well as data access methods.\\n\\npublic interface IObservableList<T> : IDisposable\\n{\\n    // Gets the count.\\n    int Count { get; }\\n\\n    // Gets observe the count changes, starting with the initial items count.\\n    IObservable<int> CountChanged { get; }\\n\\n    // Gets items enumerable.\\n    IEnumerable<T> Items { get; }\\n\\n    // Connect to the observable list \\n    // and observe any changes starting with the list's initial items.\\n    IObservable<IChangeSet<T>> Connect(Func<T, bool>? predicate = null);\\n\\n    // Connect to the observable list \\n    // and observe any changes before they are applied to the list. \\n    // Unlike Connect(), the returned observable is not prepended with\\n    // the lists initial items.\\n    IObservable<IChangeSet<T>> Preview(Func<T, bool>? predicate = null);\\n}\\n\")), mdx(\"h1\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"DynamicData.ObservableListEx.AsObservableList();\\n// Converts the source observable to an read only observable list.\\n\\npublic static IObservableList<T> \\n        AsObservableList<T>(this ISourceList<T> source); \\n\\npublic static IObservableList<T> \\n        AsObservableList<T>(this IObservable<IChangeSet<T>> source);\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"slug":"/dynamicData/DynamicData-Sorting/","previous":{"id":"872c82d8-5a60-5c25-a33d-866d3f66ef68","fields":{"slug":"/dynamicData/DynamicData-Transform/"},"frontmatter":{"title":"Dynamic Data - Transform"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dynamic Data - Transform\",\n  \"date\": \"2021-01-12 06\",\n  \"tag\": \"DynamicData, TransformMany(), AutoRefreshOnObservable, ToObservableChangeSet\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null), mdx(\"h3\", null, \"1. Flatten Observable Collection\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uC911\\uCCA9 \\uB41C \\uAD00\\uCC30 \\uAC00\\uB2A5 \\uCEEC\\uB809\\uC158\\uC744 \\uAE30\\uBC18\\uC73C\\uB85C flat cache\\uB97C \\uB9CC\\uB4E0\\uB2E4.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uBD80\\uBAA8\\uAC00 \\uCD94\\uAC00 \\uB420 \\uB54C\\uB9C8\\uB2E4 \\uC0C8\\uB85C\\uC6B4 \\uBCC0\\uACBD \\uC9D1\\uD569\\uC774 \\uC0DD\\uC131\\uB418\\uBBC0\\uB85C Batch() \\uC801\\uC6A9\\uC744 \\uAD8C\\uC7A5\\uD55C\\uB2E4.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uC54C\\uB9BC\\uC744 \\uC904\\uC774\\uAE30 \\uC704\\uD574 TransformMany() \\uC774\\uD6C4(\\uD2B9\\uD788 \\uCD08\\uAE30\\uB85C\\uB4DC\\uC2DC)\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"public IObservableCache<NestedChild, string> Children { get; }\\n\\npublic FlattenNestedObservableCollection(\\n    IObservableCache<ClassWithNestedObservableCollection, int> source)\\n{\\n    Children = source\\n        .Connect()\\n        .TransformMany(parent => parent.Children, c => c.Name)\\n            // c.Name\\uC758 \\uC720\\uC77C\\uD55C \\uAC12\\uB4E4\\uB85C parent.Children\\uB97C flat \\uD55C\\uB2E4.\\n        .AsObservableCache();\\n}\\n\\n#\\n\\nvar children = new[]\\n{\\n    new NestedChild(\\\"A\\\", \\\"ValueA\\\"),\\n    new NestedChild(\\\"B\\\", \\\"ValueB\\\"),\\n    new NestedChild(\\\"C\\\", \\\"ValueC\\\"),\\n    new NestedChild(\\\"D\\\", \\\"ValueD\\\"),\\n    new NestedChild(\\\"E\\\", \\\"ValueE\\\"),\\n    new NestedChild(\\\"F\\\", \\\"ValueF\\\")\\n};\\n\\nvar parents = new[]\\n{\\n    new ClassWithNestedObservableCollection(1, new[] { children[0], children[1] }),\\n    new ClassWithNestedObservableCollection(2, new[] { children[2], children[3] }),\\n    new ClassWithNestedObservableCollection(3, new[] { children[4] })\\n};\\n\\nusing (var source = new SourceCache<ClassWithNestedObservableCollection, int>(x => x.Id))\\nusing (var sut = new FlattenNestedObservableCollection(source))\\n{\\n    source.AddOrUpdate(parents);\\n\\n    Console.WriteLine(sut.Children.Count);  // 5\\n    foreach (var item in sut.Children.Items)\\n    {\\n        // parents.SelectMany(p => p.Children.Take(5))\\n        Console.WriteLine(item.Value);\\n    }\\n\\n    // add a child to the observable collection\\n    parents[2].Children.Add(children[5]);\\n    Console.WriteLine(sut.Children.Count);  // 6\\n    Console.WriteLine(sut.Children.Items);  // parents.SelectMany(p => p.Children)\\n\\n    // remove a parent and check children have moved\\n    source.RemoveKey(1);\\n    Console.WriteLine(sut.Children.Count);  // 4\\n    Console.WriteLine(sut.Children.Items);  // parents.SelectMany(p => p.Children)\\n\\n    // add a parent and check items have been added back in\\n    source.AddOrUpdate(parents[0]);\\n    Console.WriteLine(sut.Children.Count);  // 6\\n    Console.WriteLine(sut.Children.Items);  // parents.SelectMany(p => p.Children)\\n}\\n\")), mdx(\"h1\", null), mdx(\"h3\", null, \"2. Flatten Observable Collection With Projection From ObservableCache\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"public int Id { get; }\\npublic ObservableCollection<NestedChild> Children { get; }\\n\\npublic ClassWithNestedObservableCollection(int id, IEnumerable<NestedChild> animals)\\n{\\n    Id = id;\\n    Children = new ObservableCollection<NestedChild>(animals);\\n}\\n\\n#\\n\\nvar children = new[]\\n{\\n    new NestedChild(\\\"A\\\", \\\"ValueA\\\"),\\n    new NestedChild(\\\"B\\\", \\\"ValueB\\\"),\\n    new NestedChild(\\\"C\\\", \\\"ValueC\\\"),\\n    new NestedChild(\\\"D\\\", \\\"ValueD\\\"),\\n    new NestedChild(\\\"E\\\", \\\"ValueE\\\"),\\n    new NestedChild(\\\"F\\\", \\\"ValueF\\\")\\n};\\n\\nvar parents = new[]\\n{\\n    new ClassWithNestedObservableCollection(1, new[] { children[0], children[1] }),\\n    new ClassWithNestedObservableCollection(2, new[] { children[2], children[3] }),\\n    new ClassWithNestedObservableCollection(3, new[] { children[4] })\\n};\\n\\nusing (var source = new SourceCache<ClassWithNestedObservableCollection, int>(x => x.Id))\\nusing (var sut = source\\n        .Connect()\\n        .AutoRefreshOnObservable(self => self.Children.ToObservableChangeSet())\\n            // The refresh is triggered when the observable receives a notification.\\n        .TransformMany(\\n            parent => parent.Children.Select(c => new ProjectedNestedChild(parent, c)), \\n            c => c.Child.Name)\\n                // parent.Children\\uC774 ProjectedNestedChild\\uC73C\\uB85C new form\\uB41C \\uAC83\\uC744 \\n                // c.Child.Name\\uC744 \\uAE30\\uC900\\uC73C\\uB85C flat ObservableCache\\uB97C \\uB9CC\\uB4E0\\uB2E4.\\n        .AsObservableCache())\\n{\\n    source.AddOrUpdate(parents);\\n\\n    Console.WriteLine(sut.Count);  // 5\\n    foreach (var item in sut.Items)\\n        {\\n            // parents.SelectMany(\\n            //    p => p.children.Take(5).Select(c => new ProjectedNestedChild(p, c)));\\n            Console.WriteLine(item.Child.Value);\\n        }\\n\\n    // add a child to the observable collection\\n    parents[2].Children.Add(children[5]);\\n\\n    Console.WriteLine(sut.Count);  // 6\\n    Console.WriteLine(sut.Items);\\n    // parents.SelectMany(p => p.children.Select(c => new ProjectedNestedChild(p, c)));\\n\\n    // remove a parent and check children have moved\\n    source.RemoveKey(1);\\n    Console.WriteLine(sut.Count);  // 4\\n    Console.WriteLine(sut.Items);\\n    // parents.SelectMany(\\n    //    p => p.children.skip(1).Select(c => new ProjectedNestedChild(p, c)));\\n\\n    // add a parent and check items have been added back in\\n    source.AddOrUpdate(parents[0]);\\n\\n    Console.WriteLine(sut.Count);  // 6\\n    Console.WriteLine(sut.Items);\\n    // parents.SelectMany(p => p.children.Select(c => new ProjectedNestedChild(p, c)));\\n\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"AutoRefreshOnObservable()\\n// Automatically refresh downstream operator. \\n// The refresh is triggered when the observable receives a notification.\\n\\nIObservable<IChangeSet<TObject, TKey>> \\n    AutoRefreshOnObservable<TObject, TKey, TAny>(\\n        this IObservable<IChangeSet<TObject, TKey>> source, \\n        Func<TObject, IObservable<TAny>> reevaluator, \\n        TimeSpan? changeSetBuffer = null, \\n        IScheduler? scheduler = null) where TKey : notnull;\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// 4. Creating Observable Change Sets : IObservable<IChangeSet<TObject,TKey>>\\n\\nToObservableChangeSet()  \\n// Convert an observable collection into an observable change set.\\n\\n// 4.2 from an Rx Observable.\\n//     form an Observable Collection.\\n//     from an Binding List.\\nIObservable<IChangeSet<TObject,TKey>> \\n    IObservable<IEnumerable<T>>.ToObservableChangeSet(t=> t.key);\\n\")), mdx(\"h1\", null), mdx(\"h3\", null, \"3. Flatten Observable Collection With Projection From ObservableList\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"public class ProjectNestedChildEqualityComparer : IEqualityComparer<ProjectedNestedChild>\\n{\\n    public bool Equals(ProjectedNestedChild x, ProjectedNestedChild y)\\n    {\\n        if (x == null || y == null)\\n        {\\n            return false;\\n        }\\n\\n        return x.Child.Name == y.Child.Name;\\n    }\\n\\n    public int GetHashCode([DisallowNull] ProjectedNestedChild obj)\\n    {\\n        return obj.Child.Name.GetHashCode();\\n    }\\n}\\n\\n#\\n\\nusing (var source = new SourceList<ClassWithNestedObservableCollection>())\\nusing (var sut = source\\n        .Connect()\\n        .AutoRefreshOnObservable(self => self.Children.ToObservableChangeSet())\\n        .TransformMany(\\n            parent => parent.Children.Select(c => new ProjectedNestedChild(parent, c)), \\n            new ProjectNestedChildEqualityComparer())\\n            // IEqualityComparer<ProjectedNestedChild>\\uB97C \\n            // \\uC774\\uC6A9\\uD574 flat ObservableList\\uB97C \\uB9CC\\uB4E0\\uB2E4.\\n        .AsObservableList())\\n{\\n    source.AddRange(parents);\\n\\n    Console.WriteLine(sut.Count);  // 5\\n    Console.WriteLine(sut.Items);\\n    // parents.SelectMany(\\n    //    p => p.Children.Take(5).Select(c => new ProjectedNestedChild(p, c)))\\n\\n    // add a child to the observable collection\\n    parents[2].Children.Add(children[5]);\\n    Console.WriteLine(sut.Count);  // 6\\n    Console.WriteLine(sut.Items);\\n    // parents.SelectMany(p => p.Children.Select(c => new ProjectedNestedChild(p, c)))\\n\\n    // remove a parent and check children have moved\\n    source.Remove(parents[0]);\\n    Console.WriteLine(sut.Count);  // 4\\n    Console.WriteLine(sut.Items);\\n    // parents.SelectMany(\\n    //    p => p.Children.Skip(1).Select(c => new ProjectedNestedChild(p, c)))\\n\\n    // add a parent and check items have been added back in\\n    source.Add(parents[0]);\\n\\n    Console.WriteLine(sut.Count);  // 6\\n    Console.WriteLine(sut.Items);\\n    // parents.SelectMany(p => p.Children.Select(c => new ProjectedNestedChild(p, c)))\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"next":{"id":"240cce73-7b1b-58f2-9ab8-0828aa52492a","fields":{"slug":"/dynamicData/DynamicData-Filtering/"},"frontmatter":{"title":"Dynamic Data - Filtering"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dynamic Data - Filtering\",\n  \"date\": \"2021-01-12 08\",\n  \"tag\": \"DynamicData, Filtering, IObservableList<T>, AsObservableList(), SourceList<T>, FilterOnProperty()\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null), mdx(\"h3\", null, \"1. Static Filter\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uAE30\\uBCF8 \\uBAA9\\uB85D\\uC774 \\uCD94\\uAC00 \\uB610\\uB294 \\uC0AD\\uC81C\\uB97C \\uC218\\uC2E0 \\uD560 \\uB54C\\uB9CC Mammals\\uBCC4\\uB85C \\uC790\\uB3D9 \\uD544\\uD130\\uB9C1\\uB41C\\uB2E4.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"public StaticFilter(IObservableList<Animal> source)\\n{\\n    // \\uC774 \\uBAA9\\uB85D\\uC740 \\uAE30\\uBCF8 \\uBAA9\\uB85D\\uC774 \\uCD94\\uAC00 \\uB610\\uB294 \\uC81C\\uAC70\\uB97C \\uC218\\uC2E0 \\uD560 \\uB54C\\uB9CC\\n    // Mammals\\uBCC4\\uB85C \\uC790\\uB3D9 \\uD544\\uD130\\uB9C1\\uB41C\\uB2E4.\\n    Mammals = source\\n        .Connect()\\n        .Filter(animal => animal.Family == AnimalFamily.Mammal)\\n        .AsObservableList();\\n\\n    this.cleanUp = Mammals;\\n}\\n\\n#\\n\\nusing (var sourceList = new SourceList<Animal>())\\nusing (var sut = new StaticFilter(sourceList))\\n{\\n    sourceList.AddRange(items);\\n\\n    // items.Where(a=>a.Family == AnimalFamily.Mammal)\\n    Console.WriteLine(sut.Mammals.Items);\\n    Console.WriteLine(sut.Mammals.Count);  // 5\\n\\n    // add a new mammal to show it is included in the result set\\n    sourceList.Add(new Animal(\\\"Bob\\\", \\\"Human\\\", AnimalFamily.Mammal));\\n    Console.WriteLine(sut.Mammals.Count);  // 6\\n\\n    // remove the first 4 items which will leave 2 mammals\\n    sourceList.RemoveRange(0, 4);\\n    Console.WriteLine(sut.Mammals.Count); // 2\\n}\\n\")), mdx(\"h1\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// DynamicData.IObservableList<T>\\n// A readonly observable list, \\n// providing observable methods as well as data access methods.\\n\\npublic interface IObservableList<T> : IDisposable\\n{\\n    // Gets the count.\\n    int Count { get; }\\n\\n    // Gets observe the count changes, starting with the initial items count.\\n    IObservable<int> CountChanged { get; }\\n\\n    // Gets items enumerable.\\n    IEnumerable<T> Items { get; }\\n\\n    // Connect to the observable list \\n    // and observe any changes starting with the list's initial items.\\n    IObservable<IChangeSet<T>> Connect(Func<T, bool>? predicate = null);\\n\\n    // Connect to the observable list \\n    // and observe any changes before they are applied to the list. \\n    // Unlike Connect(), the returned observable is not prepended with\\n    // the lists initial items.\\n    IObservable<IChangeSet<T>> Preview(Func<T, bool>? predicate = null);\\n}\\n\")), mdx(\"h1\", null), mdx(\"h1\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// DynamicData.SourceList<T> : ISourceList<T>, IObservableList<T>, IDisposable\\n\\npublic sealed class SourceList<T> : ISourceList<T>, IObservableList<T>, IDisposable\\n{\\n    public SourceList(IObservable<IChangeSet<T>>? source = null);\\n\\n    public int Count { get; }\\n    public IObservable<int> CountChanged { get; }\\n    public IEnumerable<T> Items { get; }\\n\\n    public IObservable<IChangeSet<T>> Connect(Func<T, bool>? predicate = null);\\n    public void Dispose();\\n    public void Edit(Action<IExtendedList<T>> updateAction);\\n    public IObservable<IChangeSet<T>> Preview(Func<T, bool>? predicate = null);\\n}\\n\\n// \\uC77D\\uAE30\\uC804\\uC6A9\\uC73C\\uB85C \\uD30C\\uC0DD \\uCEEC\\uB809\\uC158\\uC744 \\uB9CC\\uB4E4\\uC5B4 \\uB178\\uCD9C\\n// IObservable<IChangeSet<T>>.AsObservableList()\\n// return type : IObservableList<T>\\n\\n// IObservableList<T>.Connect()\\n// return type : IObservable<IChangeSet<T>>\\n\")), mdx(\"h1\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"DynamicData.ObservableListEx.AsObservableList();\\n// Converts the source observable to an read only observable list.\\n\\npublic static IObservableList<T> \\n        AsObservableList<T>(this ISourceList<T> source); \\n\\npublic static IObservableList<T> \\n        AsObservableList<T>(this IObservable<IChangeSet<T>> source);\\n\")), mdx(\"h1\", null), mdx(\"h3\", null, \"2. Dynamic Filter\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Create list which automatically filters when AnimalFilter changes\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"public IObservableList<Animal> Filtered { get; }\\n\\npublic DynamicFilter(IObservableList<Animal> source, ISchedulerProvider schedulerProvider)\\n{\\n    // AnimalFilter \\uC18D\\uC131\\uC774 \\uBCC0\\uACBD \\uB420 \\uB54C\\uB9C8\\uB2E4 new predicate\\uB97C \\uC0DD\\uC131\\uD558\\uB294 observable\\uC744 \\uC0DD\\uC131\\uD55C\\uB2E4.\\n    var dynamicFilter = this\\n        .WhenValueChanged(@this => @this.AnimalFilter)\\n        .Throttle(TimeSpan.FromMilliseconds(250), schedulerProvider.Background)\\n        //throttle to prevent constant filtering (i.e. when users type)\\n        .Select(CreatePredicate);\\n\\n    // Create list which automatically filters when AnimalFilter changes\\n    Filtered = source\\n        .Connect()\\n        .Filter(dynamicFilter)\\n        // dynamicfilter\\uB294 \\uAD00\\uCC30 \\uAC00\\uB2A5\\uD55C \\uBAA8\\uB4E0 \\uC220\\uC5B4\\uB97C \\uD5C8\\uC6A9 \\uD560 \\uC218 \\uC788\\uB2E4.\\n        // (\\uC989, \\uC18D\\uC131\\uC744 \\uAE30\\uBC18\\uC73C\\uB85C\\uD558\\uC9C0 \\uC54A\\uC544\\uB3C4 \\uB428).\\n        .AsObservableList();\\n\\n    this.cleanUp = Filtered;\\n}\\n\\nprivate Func<Animal, bool> CreatePredicate(string text)\\n{\\n    if (text == null || text.Length < 3)\\n    {\\n        return animal => true;\\n    }\\n\\n    // the more fields which are filtered on the slower it takes for the filter to apply \\n    // by generally I have never found checking a predicate to be particularly slow \\n    return animal => animal.Name.Contains(text)\\n                        || animal.Type.Contains(text)\\n                        || animal.Family.ToString().Contains(text);\\n}\\n\\n#\\n\\nvar schedulerProvider = new TestSchedulerProvider();\\nusing (var sourceList = new SourceList<Animal>())\\nusing (var sut = new DynamicFilter(sourceList, schedulerProvider))\\n{\\n    // add items\\n    sourceList.AddRange(items);\\n\\n    Console.WriteLine(sut.Filtered.Count);\\n\\n    // set a filter\\n    sut.AnimalFilter = \\\"Dog\\\";  // items.Where(a=>a.Type == \\\"Dog\\\")\\n\\n    Console.WriteLine(sut.Filtered.Count);  // 2\\n\\n    // add a new dog to show it is included in the result set\\n    sourceList.Add(new Animal(\\\"George\\\", \\\"Dog\\\", AnimalFamily.Mammal));\\n\\n    Console.WriteLine(sut.Filtered.Count);  // 3\\n\\n    // add a new bird to show it is included in the result set\\n    sourceList.Add(new Animal(\\\"Peter\\\", \\\"Parrot\\\", AnimalFamily.Bird));\\n\\n    Console.WriteLine(sut.Filtered.Count);  // 3\\n\\n    // My additions...\\n    sut.AnimalFilter = \\\"Frog\\\"; // items.Where(a => a.Type == \\\"Frog\\\")\\n\\n    Console.WriteLine(sut.Filtered.Count);  // 1\\n}\\n\")), mdx(\"h1\", null), mdx(\"h3\", null, \"3. Property Filter\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uC790\\uB3D9\\uC73C\\uB85C \\uD544\\uD130\\uB9C1\\uD558\\uB294 \\uBAA9\\uB85D \\uB9CC\\uB4E4\\uAE30\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"public class PropertyFilter : AbstractNotifyPropertyChanged, IDisposable\\n{\\n    private readonly IDisposable cleanUp;\\n    public IObservableList<Animal> Filtered { get; }\\n\\n    public PropertyFilter(IObservableList<Animal> source, \\n                            ISchedulerProvider schedulerProvider)\\n    {\\n        /*\\n        *  Create list which automatically filters : \\n        *  \\n        *  a) \\uAE30\\uBCF8 \\uBAA9\\uB85D\\uC774 \\uBCC0\\uACBD \\uB420 \\uB54C\\n        *  b) IncludeInResults \\uC18D\\uC131\\uC774 \\uBCC0\\uACBD\\uB418\\uB294 \\uACBD\\uC6B0\\n        *  c) \\uC8FC\\uC758 : IncludeInResults \\uC18D\\uC131\\uC774 \\uBE60\\uB978 sucession\\uC73C\\uB85C multiple animals\\uC5D0\\uC11C \\n        *            \\uBCC0\\uACBD \\uB420 \\uC218 \\uC788\\uB294 \\uACBD\\uC6B0 throttle\\uB97C  \\uCD94\\uAC00\\uD55C\\uB2E4.\\n        *            (\\uC989, \\uC18C\\uD488\\uC774 \\uBCC0\\uACBD \\uB420 \\uB54C\\uB9C8\\uB2E4 \\uD544\\uD130\\uAC00 \\uC7AC\\uD3C9\\uAC00\\uB418\\uC5B4 \\uC7A0\\uC7AC\\uC801\\uC73C\\uB85C \\n        *                 \\uC5C5\\uB370\\uC774\\uD2B8\\uAC00 \\uAE09\\uC99D \\uD560 \\uC218 \\uC788\\uB2E4. \\uC18D\\uB3C4\\uB97C \\uB2A6\\uCD94\\uB294 \\uAC83\\uC774 \\uC88B\\uB2E4.)\\n        */\\n\\n        Filtered = source\\n            .Connect()\\n            .FilterOnProperty(\\n                animal => animal.IncludeInResults,\\n                animal => animal.IncludeInResults,\\n                TimeSpan.FromMilliseconds(250),\\n                schedulerProvider.MainThread)\\n            .AsObservableList();\\n    }\\n\\n    public void Dispose()\\n    {\\n        this.cleanUp.Dispose();\\n    }\\n}\\n\\n#\\n\\nvar schedulerProvider = new TestSchedulerProvider();\\nusing (var sourceList = new SourceList<Animal>())\\nusing (var sut = new PropertyFilter(sourceList, schedulerProvider))\\n{\\n    // add items\\n    sourceList.AddRange(items);\\n    Console.WriteLine(sut.Filtered.Count);  // 0\\n\\n    // set to true to include in the result set\\n    items[1].IncludeInResults = true;\\n    items[2].IncludeInResults = true;\\n    items[3].IncludeInResults = true;\\n\\n    Console.WriteLine(sut.Filtered.Items);  // itmes[1], items[2], items[3]\\n}\\n\")), mdx(\"h1\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"DynamicData.ObservableListEx.FilterOnProperty();\\n// buffer\\uC758 \\uC791\\uC5C5 \\uACB0\\uACFC\\uB97C change set\\uB85C \\uBCC0\\uD658\\uD55C\\uB2E4.\\n\\npublic static IObservable<IChangeSet<TObject>> \\n    FilterOnProperty<TObject, TProperty>(this IObservable<IChangeSet<TObject>> source, \\n        Expression<Func<TObject, TProperty>> propertySelector, \\n        Func<TObject, bool> predicate, TimeSpan? propertyChangedThrottle = null, \\n        IScheduler? scheduler = null) where TObject : INotifyPropertyChang\\n\\n\")), mdx(\"h1\", null), mdx(\"h3\", null, \"4. External Source Filter\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uB2E4\\uB978 \\uD544\\uD130\\uC758 \\uACB0\\uACFC\\uC5D0\\uC11C \\uD544\\uD130\\uB9C1 \\uB41C \\uBAA9\\uB85D \\uB9CC\\uB4E4\\uAE30\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"public class ExternalSourceFilter : AbstractNotifyPropertyChanged, IDisposable\\n{\\n    private readonly IDisposable cleanUp;\\n    public IObservableList<Animal> Filtered { get; }\\n\\n    public ExternalSourceFilter(IObservableList<Animal> source, \\n                                    IObservableList<AnimalFamily> families)\\n    {\\n        /*\\n         *  Create list which is filtered from the result of another filter\\n         */\\n\\n        var familyFilter = families\\n            .Connect()\\n            .ToCollection()\\n            .Select(items =>\\n            {\\n                bool Predicate(Animal animal) => items.Contains(animal.Family);\\n                return (Func<Animal, bool>)Predicate;\\n            });\\n\\n        Filtered = source\\n            .Connect()\\n            .Filter(familyFilter)\\n            .AsObservableList();\\n\\n        this.cleanUp = Filtered;\\n    }\\n\\n    public void Dispose()\\n    {\\n        this.cleanUp.Dispose();\\n    }\\n}\\n\\n#\\n\\nusing (var sourceList = new SourceList<Animal>())\\nusing (var families = new SourceList<AnimalFamily>())\\nusing (var sut = new ExternalSourceFilter(sourceList, families))\\n{\\n    // add items to source\\n    sourceList.AddRange(items);\\n    Console.WriteLine(sut.Filtered.Count);  // 0\\n\\n    families.AddRange(new []{ AnimalFamily.Amphibian, AnimalFamily.Bird });\\n    Console.WriteLine(sut.Filtered.Items);  \\n    //  items.Where(a => a.Family == AnimalFamily.Amphibian \\n    //  || a.Family==AnimalFamily.Bird)\\n\\n    families.Remove(AnimalFamily.Amphibian);\\n    Console.WriteLine(sut.Filtered.Items);  \\n    //  Where(a => a.Family == AnimalFamily.Bird)\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}}},"staticQueryHashes":[]}