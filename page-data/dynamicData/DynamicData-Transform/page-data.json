{"componentChunkName":"component---src-templates-archive-post-js","path":"/dynamicData/DynamicData-Transform/","result":{"data":{"mdx":{"id":"872c82d8-5a60-5c25-a33d-866d3f66ef68","excerpt":"1. Flatten Observable Collection 중첩 된 관찰 가능 컬렉션을 기반으로 flat cache를 만든다. 부모가 추가 될 때마다 새로운 변경 집합이 생성되므로 Batch() 적용을 권장한다. 알림을 줄이기 위해 TransformMany() 이후(특히 초기로드시)…","frontmatter":{"title":"Dynamic Data - Transform","date":"January 12, 2021","tag":"DynamicData, TransformMany(), AutoRefreshOnObservable, ToObservableChangeSet"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dynamic Data - Transform\",\n  \"date\": \"2021-01-12 06\",\n  \"tag\": \"DynamicData, TransformMany(), AutoRefreshOnObservable, ToObservableChangeSet\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null), mdx(\"h3\", null, \"1. Flatten Observable Collection\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uC911\\uCCA9 \\uB41C \\uAD00\\uCC30 \\uAC00\\uB2A5 \\uCEEC\\uB809\\uC158\\uC744 \\uAE30\\uBC18\\uC73C\\uB85C flat cache\\uB97C \\uB9CC\\uB4E0\\uB2E4.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uBD80\\uBAA8\\uAC00 \\uCD94\\uAC00 \\uB420 \\uB54C\\uB9C8\\uB2E4 \\uC0C8\\uB85C\\uC6B4 \\uBCC0\\uACBD \\uC9D1\\uD569\\uC774 \\uC0DD\\uC131\\uB418\\uBBC0\\uB85C Batch() \\uC801\\uC6A9\\uC744 \\uAD8C\\uC7A5\\uD55C\\uB2E4.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uC54C\\uB9BC\\uC744 \\uC904\\uC774\\uAE30 \\uC704\\uD574 TransformMany() \\uC774\\uD6C4(\\uD2B9\\uD788 \\uCD08\\uAE30\\uB85C\\uB4DC\\uC2DC)\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"public IObservableCache<NestedChild, string> Children { get; }\\n\\npublic FlattenNestedObservableCollection(\\n    IObservableCache<ClassWithNestedObservableCollection, int> source)\\n{\\n    Children = source\\n        .Connect()\\n        .TransformMany(parent => parent.Children, c => c.Name)\\n            // c.Name\\uC758 \\uC720\\uC77C\\uD55C \\uAC12\\uB4E4\\uB85C parent.Children\\uB97C flat \\uD55C\\uB2E4.\\n        .AsObservableCache();\\n}\\n\\n#\\n\\nvar children = new[]\\n{\\n    new NestedChild(\\\"A\\\", \\\"ValueA\\\"),\\n    new NestedChild(\\\"B\\\", \\\"ValueB\\\"),\\n    new NestedChild(\\\"C\\\", \\\"ValueC\\\"),\\n    new NestedChild(\\\"D\\\", \\\"ValueD\\\"),\\n    new NestedChild(\\\"E\\\", \\\"ValueE\\\"),\\n    new NestedChild(\\\"F\\\", \\\"ValueF\\\")\\n};\\n\\nvar parents = new[]\\n{\\n    new ClassWithNestedObservableCollection(1, new[] { children[0], children[1] }),\\n    new ClassWithNestedObservableCollection(2, new[] { children[2], children[3] }),\\n    new ClassWithNestedObservableCollection(3, new[] { children[4] })\\n};\\n\\nusing (var source = new SourceCache<ClassWithNestedObservableCollection, int>(x => x.Id))\\nusing (var sut = new FlattenNestedObservableCollection(source))\\n{\\n    source.AddOrUpdate(parents);\\n\\n    Console.WriteLine(sut.Children.Count);  // 5\\n    foreach (var item in sut.Children.Items)\\n    {\\n        // parents.SelectMany(p => p.Children.Take(5))\\n        Console.WriteLine(item.Value);\\n    }\\n\\n    // add a child to the observable collection\\n    parents[2].Children.Add(children[5]);\\n    Console.WriteLine(sut.Children.Count);  // 6\\n    Console.WriteLine(sut.Children.Items);  // parents.SelectMany(p => p.Children)\\n\\n    // remove a parent and check children have moved\\n    source.RemoveKey(1);\\n    Console.WriteLine(sut.Children.Count);  // 4\\n    Console.WriteLine(sut.Children.Items);  // parents.SelectMany(p => p.Children)\\n\\n    // add a parent and check items have been added back in\\n    source.AddOrUpdate(parents[0]);\\n    Console.WriteLine(sut.Children.Count);  // 6\\n    Console.WriteLine(sut.Children.Items);  // parents.SelectMany(p => p.Children)\\n}\\n\")), mdx(\"h1\", null), mdx(\"h3\", null, \"2. Flatten Observable Collection With Projection From ObservableCache\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"public int Id { get; }\\npublic ObservableCollection<NestedChild> Children { get; }\\n\\npublic ClassWithNestedObservableCollection(int id, IEnumerable<NestedChild> animals)\\n{\\n    Id = id;\\n    Children = new ObservableCollection<NestedChild>(animals);\\n}\\n\\n#\\n\\nvar children = new[]\\n{\\n    new NestedChild(\\\"A\\\", \\\"ValueA\\\"),\\n    new NestedChild(\\\"B\\\", \\\"ValueB\\\"),\\n    new NestedChild(\\\"C\\\", \\\"ValueC\\\"),\\n    new NestedChild(\\\"D\\\", \\\"ValueD\\\"),\\n    new NestedChild(\\\"E\\\", \\\"ValueE\\\"),\\n    new NestedChild(\\\"F\\\", \\\"ValueF\\\")\\n};\\n\\nvar parents = new[]\\n{\\n    new ClassWithNestedObservableCollection(1, new[] { children[0], children[1] }),\\n    new ClassWithNestedObservableCollection(2, new[] { children[2], children[3] }),\\n    new ClassWithNestedObservableCollection(3, new[] { children[4] })\\n};\\n\\nusing (var source = new SourceCache<ClassWithNestedObservableCollection, int>(x => x.Id))\\nusing (var sut = source\\n        .Connect()\\n        .AutoRefreshOnObservable(self => self.Children.ToObservableChangeSet())\\n            // The refresh is triggered when the observable receives a notification.\\n        .TransformMany(\\n            parent => parent.Children.Select(c => new ProjectedNestedChild(parent, c)), \\n            c => c.Child.Name)\\n                // parent.Children\\uC774 ProjectedNestedChild\\uC73C\\uB85C new form\\uB41C \\uAC83\\uC744 \\n                // c.Child.Name\\uC744 \\uAE30\\uC900\\uC73C\\uB85C flat ObservableCache\\uB97C \\uB9CC\\uB4E0\\uB2E4.\\n        .AsObservableCache())\\n{\\n    source.AddOrUpdate(parents);\\n\\n    Console.WriteLine(sut.Count);  // 5\\n    foreach (var item in sut.Items)\\n        {\\n            // parents.SelectMany(\\n            //    p => p.children.Take(5).Select(c => new ProjectedNestedChild(p, c)));\\n            Console.WriteLine(item.Child.Value);\\n        }\\n\\n    // add a child to the observable collection\\n    parents[2].Children.Add(children[5]);\\n\\n    Console.WriteLine(sut.Count);  // 6\\n    Console.WriteLine(sut.Items);\\n    // parents.SelectMany(p => p.children.Select(c => new ProjectedNestedChild(p, c)));\\n\\n    // remove a parent and check children have moved\\n    source.RemoveKey(1);\\n    Console.WriteLine(sut.Count);  // 4\\n    Console.WriteLine(sut.Items);\\n    // parents.SelectMany(\\n    //    p => p.children.skip(1).Select(c => new ProjectedNestedChild(p, c)));\\n\\n    // add a parent and check items have been added back in\\n    source.AddOrUpdate(parents[0]);\\n\\n    Console.WriteLine(sut.Count);  // 6\\n    Console.WriteLine(sut.Items);\\n    // parents.SelectMany(p => p.children.Select(c => new ProjectedNestedChild(p, c)));\\n\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"AutoRefreshOnObservable()\\n// Automatically refresh downstream operator. \\n// The refresh is triggered when the observable receives a notification.\\n\\nIObservable<IChangeSet<TObject, TKey>> \\n    AutoRefreshOnObservable<TObject, TKey, TAny>(\\n        this IObservable<IChangeSet<TObject, TKey>> source, \\n        Func<TObject, IObservable<TAny>> reevaluator, \\n        TimeSpan? changeSetBuffer = null, \\n        IScheduler? scheduler = null) where TKey : notnull;\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// 4. Creating Observable Change Sets : IObservable<IChangeSet<TObject,TKey>>\\n\\nToObservableChangeSet()  \\n// Convert an observable collection into an observable change set.\\n\\n// 4.2 from an Rx Observable.\\n//     form an Observable Collection.\\n//     from an Binding List.\\nIObservable<IChangeSet<TObject,TKey>> \\n    IObservable<IEnumerable<T>>.ToObservableChangeSet(t=> t.key);\\n\")), mdx(\"h1\", null), mdx(\"h3\", null, \"3. Flatten Observable Collection With Projection From ObservableList\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"public class ProjectNestedChildEqualityComparer : IEqualityComparer<ProjectedNestedChild>\\n{\\n    public bool Equals(ProjectedNestedChild x, ProjectedNestedChild y)\\n    {\\n        if (x == null || y == null)\\n        {\\n            return false;\\n        }\\n\\n        return x.Child.Name == y.Child.Name;\\n    }\\n\\n    public int GetHashCode([DisallowNull] ProjectedNestedChild obj)\\n    {\\n        return obj.Child.Name.GetHashCode();\\n    }\\n}\\n\\n#\\n\\nusing (var source = new SourceList<ClassWithNestedObservableCollection>())\\nusing (var sut = source\\n        .Connect()\\n        .AutoRefreshOnObservable(self => self.Children.ToObservableChangeSet())\\n        .TransformMany(\\n            parent => parent.Children.Select(c => new ProjectedNestedChild(parent, c)), \\n            new ProjectNestedChildEqualityComparer())\\n            // IEqualityComparer<ProjectedNestedChild>\\uB97C \\n            // \\uC774\\uC6A9\\uD574 flat ObservableList\\uB97C \\uB9CC\\uB4E0\\uB2E4.\\n        .AsObservableList())\\n{\\n    source.AddRange(parents);\\n\\n    Console.WriteLine(sut.Count);  // 5\\n    Console.WriteLine(sut.Items);\\n    // parents.SelectMany(\\n    //    p => p.Children.Take(5).Select(c => new ProjectedNestedChild(p, c)))\\n\\n    // add a child to the observable collection\\n    parents[2].Children.Add(children[5]);\\n    Console.WriteLine(sut.Count);  // 6\\n    Console.WriteLine(sut.Items);\\n    // parents.SelectMany(p => p.Children.Select(c => new ProjectedNestedChild(p, c)))\\n\\n    // remove a parent and check children have moved\\n    source.Remove(parents[0]);\\n    Console.WriteLine(sut.Count);  // 4\\n    Console.WriteLine(sut.Items);\\n    // parents.SelectMany(\\n    //    p => p.Children.Skip(1).Select(c => new ProjectedNestedChild(p, c)))\\n\\n    // add a parent and check items have been added back in\\n    source.Add(parents[0]);\\n\\n    Console.WriteLine(sut.Count);  // 6\\n    Console.WriteLine(sut.Items);\\n    // parents.SelectMany(p => p.Children.Select(c => new ProjectedNestedChild(p, c)))\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"slug":"/dynamicData/DynamicData-Transform/","previous":{"id":"defeafcb-224e-5ca4-9cd1-657d0705e244","fields":{"slug":"/dynamicData/DynamicData-Switch/"},"frontmatter":{"title":"Dynamic Data - Switch"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dynamic Data - Switch\",\n  \"date\": \"2021-01-12 05\",\n  \"tag\": \"DynamicData, Switch()\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null), mdx(\"h3\", null, \"1. Switch\"), mdx(\"p\", null, \"\\uB370\\uC774\\uD130\\uC758 \\uC804\\uD658\\uC740 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IObservable<IChangeSet<T>>\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IObservable<IObservableList<T>>\"), \"\\uC5D0\\uC11C \\uC791\\uB3D9\\uD55C\\uB2E4.\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"The same concept applies to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ObservableCache\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"public IObservableList<int> DataSource { get; }\\n\\npublic SwitchDataSource(IObservableList<int> sourceA, IObservableList<int> sourceB)\\n{\\n    DataSource = this\\n        .WhenValueChanged(@this => @this.Option)\\n        .Select(opt => opt == SwitchDataSoruceOption.SourceA ? sourceA : sourceB)\\n        .Switch()  // this is dynamic data overload of Switch()\\n        .AsObservableList();\\n\\n    this.cleanUp = DataSource;\\n}\\n\\n#\\n\\npublic class SourceList<T> : ISourceList<T>, IObservableList<T>, IDisposable\\npublic class SourceCache<TObject, TKey> : ISourceCache<TObject, TKey>, \\n    IObservableCache<TObject, TKey>, IConnectableCache<TObject, TKey>, IDisposable \\n    where TKey : notnull\\n\\n#\\n\\nusing (var listA = new SourceList<int>())\\nusing (var listB = new SourceList<int>())\\nusing (var sut = new SwitchDataSource.SwitchDataSource(listA, listB))\\n{\\n    var oddNumbers = Enumerable\\n        .Range(1, 10000)\\n        .Where(i => i % 2 == 1).ToArray();\\n    var evenNumbers = Enumerable\\n        .Range(1, 10000)\\n        .Where(i => i % 2 == 2).ToArray();\\n\\n    listA.AddRange(oddNumbers);\\n    listB.AddRange(evenNumbers);\\n\\n    sut.Option = SwitchDataSource.SwitchDataSoruceOption.SourceB;\\n    foreach (var item in sut.DataSource.Items)\\n    {\\n        Console.WriteLine(item);  // evenNumbers\\n    }\\n\\n    sut.Option = SwitchDataSource.SwitchDataSoruceOption.SourceA;\\n    foreach (var item in sut.DataSource.Items)\\n    {\\n        Console.WriteLine(item);  // oddNumbers\\n    }\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"next":{"id":"db59bc31-04a3-5f24-8473-b44afa00e3fc","fields":{"slug":"/dynamicData/DynamicData-Sorting/"},"frontmatter":{"title":"Dynamic Data - Sorting"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dynamic Data - Sorting\",\n  \"date\": \"2021-01-12 07\",\n  \"tag\": \"DynamicData, Sort, Threshold, Ascending, Decending, SortExpressionComparer, AsObservableList(), ISourceList<T>, IObservableList<T>\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null), mdx(\"h3\", null, \"1. Custom Binding\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uC7AC\\uC124\\uC815 \\uC784\\uACC4\\uAC12(reset threshold)\\uC744 \\uB3D9\\uC801\\uC73C\\uB85C \\uC81C\\uC5B4\\uB420 \\uC218 \\uC788\\uB294\\uC9C0\\uC5D0 \\uB300\\uD55C \\uD655\\uC778.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"/*\\n    Sometimes the default binding does not behave exactly as you want.\\n    Using VariableThresholdObservableCollectionAdaptor is an example of \\n    how you can inject your own behaviour.\\n*/\\n\\npublic CustomBinding(IObservableCache<Animal, string> source)\\n{\\n    Threshold = 5;\\n\\n    this.cleanUp = source\\n        .Connect()\\n        .Sort(SortExpressionComparer<Animal>.Ascending(a => a.Name))\\n        .Bind(\\n          out var data, \\n          adaptor: new VariableThresholdObservableCollectionAdaptor<Animal, string>(\\n            () => Threshold))\\n        .Subscribe();\\n\\n    Data = data;\\n}\\n\\n#\\n\\nAnimal[] items = new[]\\n    {\\n        new Animal(\\\"Holly\\\", \\\"Cat\\\", AnimalFamily.Mammal),\\n        new Animal(\\\"Rover\\\", \\\"Dog\\\", AnimalFamily.Mammal),\\n        new Animal(\\\"Rex\\\", \\\"Dog\\\", AnimalFamily.Mammal),\\n        new Animal(\\\"Whiskers\\\", \\\"Cat\\\", AnimalFamily.Mammal),\\n        new Animal(\\\"Nemo\\\", \\\"Fish\\\", AnimalFamily.Fish),\\n        new Animal(\\\"Moby Dick\\\", \\\"Whale\\\", AnimalFamily.Mammal),\\n        new Animal(\\\"Fred\\\", \\\"Frog\\\", AnimalFamily.Amphibian),\\n        new Animal(\\\"Isaac\\\", \\\"Next\\\", AnimalFamily.Amphibian),\\n        new Animal(\\\"Sam\\\", \\\"Snake\\\", AnimalFamily.Reptile),\\n        new Animal(\\\"Sharon\\\", \\\"Red Backed Shrike\\\", AnimalFamily.Bird),\\n    };\\n\\nusing (var sourceCache = new SourceCache<Animal, string>(a => a.Name))\\nusing (var sut = new CustomBinding(sourceCache))\\n{\\n    int resetCount = 0;\\n    (sut.Data as INotifyCollectionChanged).CollectionChanged += (_, e) =>\\n    {\\n        if (e.Action == NotifyCollectionChangedAction.Reset)\\n        {\\n            resetCount++;\\n        }\\n    };\\n\\n    sut.Threshold = 20;\\n    sourceCache.AddOrUpdate(items);\\n    Console.WriteLine(resetCount);  // 0\\n\\n    sut.Threshold = 9;  // itmes.Count > sut.Threshold { resetCount++ }\\n                        // \\uC218\\uC6A9 \\uC784\\uACC4\\uCE58\\uAC00 \\uCEEC\\uB809\\uC158\\uC758 \\uCE74\\uC6B4\\uD2B8\\uBCF4\\uB2E4 \\uC791\\uB2E4.\\n                        // \\uADF8\\uB798\\uC11C \\uCEEC\\uB809\\uC158 \\uCCB4\\uC778\\uC9C0\\uAC00 \\uBC1C\\uC0DD\\uD55C\\uB2E4.\\n    sourceCache.AddOrUpdate(items);\\n    Console.WriteLine(resetCount);  // 1\\n\\n    sut.Threshold = 20;\\n    sourceCache.AddOrUpdate(items);\\n    Console.WriteLine(resetCount);  // 1\\n\\n    sut.Threshold = 5;  // itmes.Count > sut.Threshold { resetCount++ }\\n    sourceCache.AddOrUpdate(items);\\n    Console.WriteLine(resetCount);  // 2\\n}\\n\")), mdx(\"h1\", null), mdx(\"h3\", null, \"2. Change Comparer\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"IObservable\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"<IComparer<T>>\"), \"\\uB97C \\uC5F0\\uC0B0\\uC790 Sort()\\uC5D0 \\uC804\\uB2EC\\uD558\\uC5EC \\uC815\\uB82C(sorting)\\uC744 \\uC804\\uD658\\uD55C\\uB2E4.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uB3D9\\uC77C\\uD55C \\uAC1C\\uB150\\uC774 ObservableCache\\uC5D0\\uB3C4 \\uC801\\uC6A9\\uB41C\\uB2E4.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"public ChangeComparereOption Option\\n{\\n    get => this.option;\\n    set => SetAndRaise(ref this.option, value);\\n}\\npublic IObservableList<int> DataSource { get; }\\n\\npublic ChangeComparer(IObservableList<int> source)\\n{\\n    IObservable<SortExpressionComparer<int>> optionChanged = this\\n        .WhenValueChanged(@this => @this.Option)\\n        .Select(opt => opt == ChangeComparereOption.Ascending\\n            ? SortExpressionComparer<int>.Ascending(i => i)\\n            : SortExpressionComparer<int>.Descending(i => i));\\n\\n    // create a sorted observable list\\n    DataSource = source\\n        .Connect()\\n        .Sort(optionChanged)\\n        .AsObservableList();\\n\\n    this.cleanUp = DataSource;\\n}\\n\\n#\\n\\nusing (var input = new SourceList<int>())\\nusing (var sut = new ChangeComparer(input))\\n{\\n    input.AddRange(randomValues);\\n    Console.WriteLine(sut.DataSource.Items);  // Should all be equivalent to ascending\\n\\n    sut.Option = ChangeComparereOption.Descending;\\n    Console.WriteLine(sut.DataSource.Items);  // Should all be equivalent to descending\\n\\n    sut.Option = ChangeComparereOption.Ascending;\\n    Console.WriteLine(sut.DataSource.Items);  // Should all be equivalent to ascending\\n}\\n\")), mdx(\"h1\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// DynamicData.SourceList<T> : ISourceList<T>, IObservableList<T>, IDisposable\\n\\npublic sealed class SourceList<T> : ISourceList<T>, IObservableList<T>, IDisposable\\n{\\n    public SourceList(IObservable<IChangeSet<T>>? source = null);\\n\\n    public int Count { get; }\\n    public IObservable<int> CountChanged { get; }\\n    public IEnumerable<T> Items { get; }\\n\\n    public IObservable<IChangeSet<T>> Connect(Func<T, bool>? predicate = null);\\n    public void Dispose();\\n    public void Edit(Action<IExtendedList<T>> updateAction);\\n    public IObservable<IChangeSet<T>> Preview(Func<T, bool>? predicate = null);\\n}\\n\\n// \\uC77D\\uAE30\\uC804\\uC6A9\\uC73C\\uB85C \\uD30C\\uC0DD \\uCEEC\\uB809\\uC158\\uC744 \\uB9CC\\uB4E4\\uC5B4 \\uB178\\uCD9C\\n// IObservable<IChangeSet<T>>.AsObservableList()\\n// return type : IObservableList<T>\\n\\n// IObservableList<T>.Connect()\\n// return type : IObservable<IChangeSet<T>>\\n\")), mdx(\"h1\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// DynamicData.IObservableList<T>\\n// A readonly observable list, \\n// providing observable methods as well as data access methods.\\n\\npublic interface IObservableList<T> : IDisposable\\n{\\n    // Gets the count.\\n    int Count { get; }\\n\\n    // Gets observe the count changes, starting with the initial items count.\\n    IObservable<int> CountChanged { get; }\\n\\n    // Gets items enumerable.\\n    IEnumerable<T> Items { get; }\\n\\n    // Connect to the observable list \\n    // and observe any changes starting with the list's initial items.\\n    IObservable<IChangeSet<T>> Connect(Func<T, bool>? predicate = null);\\n\\n    // Connect to the observable list \\n    // and observe any changes before they are applied to the list. \\n    // Unlike Connect(), the returned observable is not prepended with\\n    // the lists initial items.\\n    IObservable<IChangeSet<T>> Preview(Func<T, bool>? predicate = null);\\n}\\n\")), mdx(\"h1\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"DynamicData.ObservableListEx.AsObservableList();\\n// Converts the source observable to an read only observable list.\\n\\npublic static IObservableList<T> \\n        AsObservableList<T>(this ISourceList<T> source); \\n\\npublic static IObservableList<T> \\n        AsObservableList<T>(this IObservable<IChangeSet<T>> source);\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}}},"staticQueryHashes":[]}