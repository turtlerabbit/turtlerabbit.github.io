{"componentChunkName":"component---src-templates-archive-post-js","path":"/dynamicData/DynamicData-Testing/","result":{"data":{"mdx":{"id":"0a911901-ba7f-535f-8612-69289a1cb756","excerpt":"1. ViewModel Illustrates how to test a view model when using dynamic data","frontmatter":{"title":"Dynamic Data - Testing","date":"January 12, 2021","tag":"DynamicData, BatchIf(), ViewModel"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dynamic Data - Testing\",\n  \"date\": \"2021-01-12 10\",\n  \"tag\": \"DynamicData, BatchIf(), ViewModel\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null), mdx(\"h3\", null, \"1. ViewModel\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Illustrates how to test a view model when using dynamic data\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"public ViewModel(IDataProvider dataProvider, ISchedulerProvider schedulerProvider)\\n{\\n    var paused = this.WhenValueChanged(vm => vm.IsPaused);\\n\\n    var dataLoader = dataProvider.ItemCache\\n        .Connect()\\n        .Transform(CreateItemViewModel)\\n        .BatchIf(paused, schedulerProvider.Background) // \\uC77C\\uC2DC\\uC911\\uC9C0 + \\uBC31\\uADF8\\uB77C\\uC6B4\\uB4DC \\uD14C\\uC2A4\\uD2B8\\n        .Sort(SortExpressionComparer<ItemsViewModel>.Descending(i => i.Item.Id))\\n        .Bind(out var bindingData)\\n        .Subscribe();\\n\\n    BindingData = bindingData;\\n\\n    var counter = dataProvider.ItemCache.CountChanged\\n        .Subscribe(i => ShowEmptyView = i == 0);\\n\\n    this.cleanUp = new CompositeDisposable(dataLoader, counter);\\n}\\n\\nprivate ItemsViewModel CreateItemViewModel(Item item)\\n{\\n    return new ItemsViewModel(item);\\n}\\n\\n#\\n\\nvar schedulerProvider = new TestSchedulerProvider();\\nusing (var testData = new DataProviderStub())\\nusing (var sut = new ViewModel(testData, schedulerProvider))\\n{\\n    // Act\\n    var items = Enumerable\\n        .Range(1, 10)\\n        .Select(i => new Item(i))\\n        .ToArray();\\n    testData.Data.AddOrUpdate(items);\\n\\n    // 1. Check count of data\\n    Console.WriteLine(sut.BindingData.Count); // 10\\n\\n    // 2. Check Transform and Sort\\n    var expectedData = items\\n        .Select(i => new ItemsViewModel(i))\\n        .OrderByDescending(vm => vm.Item.Id);\\n    foreach (var item in expectedData)\\n    {\\n        Console.WriteLine(item.Item.Id);  // 10 ~ 1\\n    }\\n}\\n\")), mdx(\"h1\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"DynamicData.ObservableCacheEx.BatchIf();\\n// pause signal\\uC774 \\uC218\\uC2E0 \\uB41C \\uACBD\\uC6B0 \\uAE30\\uBCF8 \\uC5C5\\uB370\\uC774\\uD2B8\\uB97C \\uC77C\\uAD04 \\uCC98\\uB9AC\\uD55C\\uB2E4.\\n// (i.e when the buffer selector return true)\\n// resume signal\\uC774 \\uC218\\uC2E0 \\uB418\\uBA74 \\uC77C\\uAD04 \\uC5C5\\uB370\\uC774\\uD2B8\\uAC00 \\uC2E4\\uD589\\uB41C\\uB2E4.\\n\\npublic static IObservable<IChangeSet<TObject, TKey>> \\n    BatchIf<TObject, TKey>(this IObservable<IChangeSet<TObject, TKey>> source, \\n        IObservable<bool> pauseIfTrueSelector, IScheduler? scheduler = null) \\n            where TKey : notnull;\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"slug":"/dynamicData/DynamicData-Testing/","previous":{"id":"1bcb5f2d-9d91-561e-a9fd-3d8062166ff0","fields":{"slug":"/dynamicData/DynamicData-Grouping/"},"frontmatter":{"title":"Dynamic Data - Grouping"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dynamic Data - Grouping\",\n  \"date\": \"2021-01-12 09\",\n  \"tag\": \"DynamicData, Grouping, GroupWithImmutableState(), GroupOn(), ChangeKey()\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null), mdx(\"h3\", null, \"1. Group And Monitor PropertyChanges\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uC18D\\uC131\\uC758 \\uCCAB \\uAE00\\uC790\\uB97C \\uAE30\\uC900\\uC73C\\uB85C \\uADF8\\uB8F9\\uD654\\uD558\\uACE0 \\uC18D\\uC131 \\uBCC0\\uACBD\\uC2DC \\uADF8\\uB8F9\\uD654 \\uC5C5\\uB370\\uC774\\uD2B8\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"private readonly IDisposable cleanUp;\\npublic IObservableList<SpeciesGroup> SpeciesByLetter { get; }\\n\\npublic GroupAndMonitorPropertyChanges(ISourceList<Species> sourceList)\\n{\\n    var shared = sourceList.Connect().Publish();\\n\\n    // fired when the name changes on any item in the source collection\\n    var nameChanged = shared.WhenValueChanged(species => species.Name);\\n\\n    // \\uCCAB \\uAE00\\uC790\\uB85C \\uADF8\\uB8F9\\uD654 \\uD558\\uACE0\\n    // \\uC120\\uD0DD\\uC801\\uC73C\\uB85C the nameChanged observable (as a unit)\\uC744 \\uC804\\uB2EC\\uD558\\uC5EC \\n    // \\uADF8\\uB8F9\\uD654\\uAC00 \\uADF8\\uB8F9\\uD654\\uB97C \\uB2E4\\uC2DC \\uC801\\uC6A9\\uD558\\uB3C4\\uB85D \\uC9C0\\uC2DC\\uD55C\\uB2E4.\\n    SpeciesByLetter = shared\\n        .GroupWithImmutableState(x => x.Name[0], nameChanged.Select(_ => Unit.Default))\\n        .Transform(grouping => new SpeciesGroup(grouping.Key, grouping.Items))\\n        .AsObservableList();\\n\\n    // \\uC5EC\\uAE30\\uC11C species\\uC758 \\uC774\\uB984\\uC774 \\uBCC0\\uACBD\\uB418\\uBA74 \\uD30C\\uC0DD \\uBAA9\\uB85D\\uC774 \\uC790\\uCCB4\\uC801\\uC73C\\uB85C \\uC720\\uC9C0\\uB41C\\uB2E4.\\n\\n    // Nothing happens until a Published source is connect\\n    var connected = shared.Connect();\\n\\n    this.cleanUp = new CompositeDisposable(sourceList, SpeciesByLetter, connected);\\n}\\n\\n#\\n\\nusing (var sourceList = new SourceList<Species>())\\nusing (var sut = new GroupAndMonitorPropertyChanges(sourceList))\\n{\\n// populate with initial data\\nvar initialData = new[]\\n{\\n    new Species(\\\"Ant\\\"),\\n    new Species(\\\"Ape\\\"),\\n    new Species(\\\"Bear\\\"),\\n    new Species(\\\"Boar\\\"),\\n    new Species(\\\"Cougar\\\")\\n};\\nsourceList.AddRange(initialData);\\n\\n// Check all data has loaded\\nvar items = sut.SpeciesByLetter.Items.SelectMany(g => g.Items);\\nforeach (var item in items)\\n{\\n    Console.WriteLine(item.Name);  // should all be Equivalent to initialData\\n}\\n\\nvar manualGrouping = sut.SpeciesByLetter.Items;\\nforeach (var item in manualGrouping)\\n{\\n    Console.WriteLine(item.Key);  // should be Equivalent to sourceList\\n}\\n\\nConsole.WriteLine(sut.SpeciesByLetter.Count);  // 3\\n\\n// \\uB370\\uC774\\uD130\\uC758 \\uCCAB \\uAE00\\uC790\\uB97C \\uBCC0\\uACBD\\uD558\\uBA74 \\uADF8\\uB8F9\\uC774 \\uBCC0\\uACBD\\uB41C\\uB2E4.\\ninitialData[0].Name = \\\"\\uD59At\\\";  // change the first letter\\nConsole.WriteLine(sut.SpeciesByLetter.Count);  // 4\\n\\n// assert everything\\nvar assertEverything = sut.SpeciesByLetter.Items;\\nforeach (var item in assertEverything)\\n{\\n    Console.WriteLine(item.Key);  // should be Equivalent to sourceList\\n}\\n\")), mdx(\"h1\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"DynamicData.ObservableListEx.GroupWithImmutableState();\\n// group selector factory\\uC5D0\\uC11C \\uBC18\\uD658 \\uD55C \\uAC12\\uC5D0 \\uB530\\uB77C \\uC18C\\uC2A4\\uB97C \\uADF8\\uB8F9\\uD654\\uD55C\\uB2E4.\\n// \\uAC01 \\uC5C5\\uB370\\uC774\\uD2B8\\uB294 \\uBCC0\\uACBD \\uBD88\\uAC00\\uB2A5\\uD55C \\uADF8\\uB8F9\\uD654\\uB97C \\uC0DD\\uC131\\uD55C\\uB2E4.\\n\\npublic static IObservable<IChangeSet<IGrouping<TObject, TGroupKey>>> \\n    GroupWithImmutableState<TObject, TGroupKey>(\\n          this IObservable<IChangeSet<TObject>> source, \\n          Func<TObject, TGroupKey> groupSelectorKey, \\n          IObservable<Unit>? regrouper = null) where TGroupKey : notnull;\\n\")), mdx(\"h1\", null), mdx(\"h3\", null, \"2. Xamarin Forms Grouping\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Xamarin Forms\\uB97C \\uC0AC\\uC6A9\\uD55C \\uB9DE\\uCDA4\\uD615 \\uADF8\\uB8F9\\uD654\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"private readonly IDisposable cleanUp;\\nprivate Func<Animal, bool> filter = a => true;\\npublic Func<Animal, bool> Filter\\n{\\n    get => this.filter;\\n    set => SetAndRaise(ref this.filter, value);\\n}\\npublic ReadOnlyObservableCollection<AnimalGroup> FamilyGroups { get; }\\n\\npublic XamarinFormsGrouping(IObservableList<Animal> source, \\n                            ISchedulerProvider schedulerProvider)\\n{\\n    /* Xamarin forms is a bit dumb \\n      * and cannot handle nested observable collections. \\n      * To cirumvent this limitation, \\n      * create a specialist observable collection with headers \\n      * and use dynamic data to manage it */\\n\\n    // create an observable predicate\\n    var observablePredicate = this\\n        .WhenValueChanged(@this => @this.Filter)\\n        .ObserveOn(schedulerProvider.Background);\\n\\n    this.cleanUp = source\\n        .Connect()\\n        .Filter(observablePredicate)  // Apply filter dynamically                \\n        .GroupOn(arg => arg.Family)  // create a dynamic group\\n        .Transform(grouping => new AnimalGroup(grouping, schedulerProvider)) \\n                       //transform into a specialised observable collection\\n        .Sort(SortExpressionComparer<AnimalGroup>.Ascending(a => a.Family))\\n        .ObserveOn(schedulerProvider.MainThread)\\n        .Bind(out var animals)\\n        .DisposeMany() //use DisposeMany() because the grouping is disposable\\n        .Subscribe();\\n\\n    FamilyGroups = animals;\\n}\\n\\n#\\n\\nvar items = new[]\\n{\\n    new Animal(\\\"Holly\\\", \\\"Cat\\\", AnimalFamily.Mammal),\\n    new Animal(\\\"Rover\\\", \\\"Dog\\\", AnimalFamily.Mammal),\\n    new Animal(\\\"Rex\\\", \\\"Dog\\\", AnimalFamily.Mammal),\\n    new Animal(\\\"Whiskers\\\", \\\"Cat\\\", AnimalFamily.Mammal),\\n    new Animal(\\\"Nemo\\\", \\\"Fish\\\", AnimalFamily.Fish),\\n    new Animal(\\\"Moby Dick\\\", \\\"Whale\\\", AnimalFamily.Mammal),\\n    new Animal(\\\"Fred\\\", \\\"Frog\\\", AnimalFamily.Amphibian),\\n    new Animal(\\\"Isaac\\\", \\\"Next\\\", AnimalFamily.Amphibian),\\n    new Animal(\\\"Sam\\\", \\\"Snake\\\", AnimalFamily.Reptile),\\n    new Animal(\\\"Sharon\\\", \\\"Red Backed Shrike\\\", AnimalFamily.Bird),\\n};\\n\\nvar schedulerProvider = new TestSchedulerProvider();\\n\\nusing (var sourceList = new SourceList<Animal>())\\nusing (var sut = new XamarinFormsGrouping(sourceList, schedulerProvider))\\n{\\n    // populate with initial data\\n    sourceList.AddRange(items);\\n\\n    Console.WriteLine(sut.FamilyGroups.Count);  // 5\\n    Console.WriteLine(\\n      sut.FamilyGroups.Single(group => group.Family == AnimalFamily.Mammal).Count); // 5\\n    Console.WriteLine(\\n      sut.FamilyGroups.Single(group => group.Family == AnimalFamily.Fish).Count);  // 1\\n\\n    // apply a filter\\n    sut.Filter = a => a.Type == \\\"Dog\\\" || a.Type == \\\"Fish\\\";\\n\\n    Console.WriteLine(sut.FamilyGroups.Count);  // 2\\n    Console.WriteLine(\\n      sut.FamilyGroups.Single(group => group.Family == AnimalFamily.Mammal).Count); // 5\\n    Console.WriteLine(\\n      sut.FamilyGroups.Single(group => group.Family == AnimalFamily.Fish).Count);  // 1\\n\\n    // clear list and all groupings are gone\\n    sourceList.Clear();\\n    Console.WriteLine(sut.FamilyGroups.Count);  // 0\\n}\\n\")), mdx(\"h1\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"DynamicData.ObservableListEx.GroupOn();\\n// Groups the source on the value returned by group selector factory.\\n// The groupings contains an inner observable list.\\n\\npublic static IObservable<IChangeSet<IGroup<TObject, TGroup>>> \\n    GroupOn<TObject, TGroup>(this IObservable<IChangeSet<TObject>> source, \\n          Func<TObject, TGroup> groupSelector, IObservable<Unit>? regrouper = null) \\n              where TGroup : notnull;\\n\")), mdx(\"h1\", null), mdx(\"h3\", null, \"3. Custom Total Rows\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uC0AC\\uC6A9\\uC790 \\uC9C0\\uC815 \\uC9D1\\uACC4\\uC5D0 \\uADF8\\uB8F9\\uD654\\uB97C \\uC0AC\\uC6A9\\uD560 \\uC218\\uC788\\uB294 \\uBC29\\uBC95 \\uC124\\uBA85\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uC774 \\uAE30\\uC220\\uC740 \\uB3D9\\uC801 \\uB204\\uC801 \\uD569\\uACC4\\uB85C \\uADF8\\uB9AC\\uB4DC \\uB370\\uC774\\uD130\\uB97C \\uB9CC\\uB4DC\\uB294 \\uB370 \\uC0AC\\uC6A9\\uD560 \\uC218 \\uC788\\uB2E4.\", mdx(\"br\", {\n    parentName: \"li\"\n  }), \"[In production systems I also include the ability to have total row expanders - perhaps an example could follow another time]\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"private readonly IDisposable cleanUp;\\npublic IObservableCache<TradeProxy, AggregationKey> AggregatedData { get; }\\n\\npublic CustomTotalRows(IObservableCache<Trade, int> source)\\n{\\n    // 1. create a trade proxy which enriches the trade with an aggregation id.\\n    var ticker = source\\n        .Connect()\\n        .ChangeKey(proxy => \\n            new AggregationKey(AggregationType.Item, proxy.Id.ToString()))\\n        .Transform((trade, key) => new TradeProxy(trade, key));\\n\\n    // 2. create grouping based on each ticker\\n    var tickerTotals = source\\n        .Connect()\\n        .GroupWithImmutableState(trade => \\n            new AggregationKey(AggregationType.SubTotal, trade.Ticker))\\n        .Transform(grouping => new TradeProxy(grouping.Items.ToArray(), grouping.Key));\\n\\n    // 3. create grouping of 1 so we can create grand total row\\n    var overallTotal = source\\n        .Connect()\\n        .GroupWithImmutableState(trade => \\n            new AggregationKey(AggregationType.GrandTotal, \\\"All\\\"))\\n        .Transform(grouping => new TradeProxy(grouping.Items.ToArray(), grouping.Key));\\n\\n    // 4. join all togather so results are in a single cache\\n    AggregatedData = ticker\\n        .Or(overallTotal)\\n        .Or(tickerTotals)\\n        .AsObservableCache();\\n\\n    this.cleanUp = AggregatedData;\\n}\\n\\n#\\n\\nconst string USD = \\\"USD\\\";\\nconst string GBP = \\\"GBP\\\";\\nconst string CHF = \\\"CHF\\\";\\n\\nvar items = new[]\\n{\\n    new Trade(1, GBP, 100),\\n    new Trade(2, GBP, 200),\\n    new Trade(3, GBP, 100),\\n    new Trade(4, GBP, 200),\\n    new Trade(5, USD, 100),\\n    new Trade(6, USD, 200),\\n    new Trade(7, CHF, 100),\\n    new Trade(8, CHF, 200),\\n};\\n\\nusing (var source = new SourceCache<Trade, int>(t => t.Id))\\nusing (var sut = new CustomTotalRows(source))\\n{\\n    source.AddOrUpdate(items);\\n\\n    // should be 1 grand total row, 3 sub total rows, 8 rows\\n    Console.WriteLine(sut.AggregatedData.Count);  // 12\\n    Console.WriteLine(\\n      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.GrandTotal));\\n      // 1\\n    Console.WriteLine(\\n      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.SubTotal));\\n      // 3\\n    Console.WriteLine(\\n      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.Item)); \\n      // 8\\n    foreach (var item in sut.AggregatedData.Items.OrderBy(tp => tp.Ticker))\\n    {\\n        Console.WriteLine(item);  \\n        // Should all be equivalent to CustomTotalRowsExpectation(source)\\n    }\\n\\n    //remove all gbp rows. should be 1 grand total row, 2 sub total rows, 4 rows\\n    source.RemoveKeys(new[] { 1, 2, 3, 4 });\\n    Console.WriteLine(\\n      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.GrandTotal));\\n      // 1\\n    Console.WriteLine(\\n      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.SubTotal));\\n      // 2\\n    Console.WriteLine(\\n      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.Item)); \\n      // 4\\n    foreach (var item in sut.AggregatedData.Items.OrderBy(tp => tp.Ticker))\\n    {\\n        Console.WriteLine(item);  \\n        // Should all be equivalent to CustomTotalRowsExpectation(source)\\n    }\\n\\n    // add a previously unseen ticker - a new sub total row should have been added\\n    source.AddOrUpdate(new Trade(100, \\\"TRY\\\", 2000));\\n    Console.WriteLine(\\n      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.GrandTotal)); \\n      // 1\\n    Console.WriteLine(\\n      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.SubTotal)); \\n      // 3\\n    Console.WriteLine(\\n      sut.AggregatedData.Items.Count(tp => tp.Key.Type == AggregationType.Item)); \\n      // 5\\n    foreach (var item in sut.AggregatedData.Items.OrderBy(tp => tp.Ticker))\\n    {\\n        Console.WriteLine(item);  \\n        // Should all be equivalent to CustomTotalRowsExpectation(source)\\n    }\\n}\\n\")), mdx(\"h1\", null), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"DynamicData.ObservableListEx.ChangeKey();\\n// Changes the primary key.\\n\\npublic static IObservable<IChangeSet<TObject, TDestinationKey>> \\n    ChangeKey<TObject, TSourceKey, TDestinationKey>(this IObservable<IChangeSet<TObject, \\n        TSourceKey>> source, Func<TObject, TDestinationKey> keySelector)\\n            where TSourceKey : notnull\\n            where TDestinationKey : notnull;\\n\")), mdx(\"h1\", null), mdx(\"h3\", null, \"4. Custom Total Rows Expectation\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"IEnumerable<TradeProxy> CustomTotalRowsExpectation(SourceCache<Trade, int> source)\\n{\\n    yield return new TradeProxy(\\n        source.Items.ToArray(), \\n        new AggregationKey(AggregationType.GrandTotal, \\\"All\\\"));\\n\\n    foreach (var proxy in source.Items\\n        .GroupBy(trade => new AggregationKey(AggregationType.Item, trade.Id.ToString()))\\n        .Select(g => new TradeProxy(g.ToArray(), g.Key)))\\n    {\\n        yield return proxy;\\n    }\\n\\n    foreach (var proxy in source.Items\\n        .GroupBy(trade => new AggregationKey(AggregationType.SubTotal, trade.Ticker))\\n        .Select(g => new TradeProxy(g.ToArray(), g.Key)))\\n    {\\n        yield return proxy;\\n    }\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"next":{"id":"172c3396-2a25-5e89-9669-3ff3bd6f8adf","fields":{"slug":"/dynamicData/DynamicData-Summary/"},"frontmatter":{"title":"Dynamic Data - Summary"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Dynamic Data - Summary\",\n  \"date\": \"2021-01-13 01\",\n  \"tag\": \"DynamicData, 요약, 정리, Summary\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"1. Create Dynamic Data Collections \\uC694\\uC57D\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// 1. \\uB370\\uC774\\uD130 \\uC18C\\uC2A4:\\nSourceCache<TObject, TKey>, SourceList<TObject>\\n\\n// 2. \\uB370\\uC774\\uD0C0 \\uC18C\\uC2A4\\uC5D0 \\uBC14\\uB85C edit methods \\uC0AC\\uC6A9\\nSourceCache<TObject, TKey>.AddOrUpdata(Items);\\nSourceCache<TObject, TKey>.Edit(cache => cache.AddOrUpdata(Items));\\n\\n// 3. \\uB370\\uC774\\uD0C0 \\uC18C\\uC2A4\\uC5D0\\uC11C \\uBC14\\uB85C \\uC77D\\uAE30 \\uC804\\uC6A9 public\\uC73C\\uB85C \\uB178\\uCD9C\\uD560 \\uB54C\\n//    \\uC0C8\\uB85C\\uC6B4 observable list\\uB97C \\uB9CC\\uB4E0\\uB2E4.\\nIObservableCache<TObject,TKey> \\n    SourceCache<TObject, TKey>.AsObservableCache();\\n\\n\\n// 4. Creating Observable Change Sets : IObservable<IChangeSet<TObject,TKey>>\\n\\n// 4.1 \\uB370\\uC774\\uD0C0 \\uC18C\\uC2A4\\uC5D0 \\uBC14\\uB85C \\uC5F0\\uACB0\\nIObservable<IChangeSet<TObject,TKey>> \\n    SourceCache<TObject, TKey>.Connect();\\n\\n// 4.2 from an Rx Observable.\\n//     form an Observable Collection.\\n//     from an Binding List.\\nIObservable<IChangeSet<TObject,TKey>> \\n    IObservable<IEnumerable<T>>.ToObservableChangeSet(t=> t.key);\\n\\n// 4.3 ObservableChacneSet \\uC815\\uC801 \\uD074\\uB798\\uC2A4 \\uC0AC\\uC6A9\\nIObservable<IChangeSet<TObject,TKey>> \\n    ObservableChangeSet.Create<Trade, long>(ISourceCache<Trade, long> =>\\n    {\\n        ISourceCache<TObject, TKey>.AddOrUpdate(IEnumerable<trade>);\\n    }, trade = > trade.Id);\\n\\n// 5. Summary\\n1. observable change set\\uC5D0 \\uB300\\uD55C \\uB2E8\\uC77C \\uAD6C\\uB3C5\\uC744 \\uACF5\\uC720\\uD558\\uAE30 \\uC704\\uD574\\n    -> IObservable<IChangeSet<>>.Publish()\\n    -> Return : IConnectableObservable\\n\\n2. \\uACF5\\uC720\\uB97C \\uAC00\\uB2A5\\uD558\\uAC8C \\uB9CC\\uB4E0 \\uD6C4, \\uC77D\\uAE30\\uC804\\uC6A9\\uC778 \\uD30C\\uC0DD \\uCEEC\\uB809\\uC158\\uC744 \\uB9CC\\uB4E4\\uC5B4 \\uB178\\uCD9C\\n    -> IConnectableObservable.AsObservableCache()\\n    -> Return : IObservableCache : IConnectableCache\\n\\n3. \\uC77D\\uAE30\\uC804\\uC6A9\\uC73C\\uB85C \\uB178\\uCD9C\\uB41C \\uC678\\uBD80\\uC5D0\\uC11C change set\\uC744 \\uBC29\\uCD9C\\uD558\\uB294 observable\\uC744 \\uBC18\\uD658\\n    -> IConnectableCache.Connect()\\n    -> Return : IObservable<IChangeSet<>>\\n\\n4. \\npublic class SourceList<T> : ISourceList<T>, IObservableList<T>, IDisposable\\npublic class SourceCache<TObject, TKey> : ISourceCache<TObject, TKey>, \\n    IObservableCache<TObject, TKey>, IConnectableCache<TObject, TKey>, IDisposable \\n    where TKey : notnull\\n\")), mdx(\"h1\", null), mdx(\"h2\", null, \"2. Sample \\uC694\\uC57D\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// IEnumerable<T>\\nIEnumerable<Trade> Generate(int numberToGenerate)\\n\\n\\n// Creating Observable Change Sets : IObservable<IChangeSet<TObject,TKey>>\\nIObservable<IChangeSet<Trade,long>> \\n    ObservableChangeSet.Create<Trade, long>(ISourceCache<Trade, long> =>\\n    {\\n        ISourceCache<Trade, long>.AddOrUpdate(Generate());\\n    }, trade = > trade.Id);\\n\\n\\n// \\uAE30\\uBCF8 \\uC2DC\\uD000\\uC2A4(Observbale Change Sets)\\uC5D0 \\uB300\\uD55C \\uB2E8\\uC77C \\uAD6C\\uB3C5\\uC744 \\uACF5\\uC720\\uD558\\uAE30 \\uC704\\uD574\\nIConnectableObservable<IChangeSet<Trade, long>> \\n    IObservable<IChangeSet<Trade, long>>.Publish();\\n\\n\\n// \\uC77D\\uAE30\\uC804\\uC6A9\\uC778 \\uD30C\\uC0DD \\uCEEC\\uB809\\uC158\\uC744 \\uB9CC\\uB4E4\\uC5B4 \\uB178\\uCD9C\\uD558\\uAE30 \\uC704\\uD574\\nIObservableCache<Trade, long> \\n    IConnectableObservable<IChangeSet<Trade, long>>.AsObservableCache();\\n\\n\\n// IObservableCache\\uB294 IConnectableCache\\uB97C \\uC0C1\\uC18D\\uBC1B\\uC740 \\uBAA8\\uC2B5\\uC774\\uB2E4.\\npublic interface IObservableCache<TObject, TKey>\\n    : IConnectableCache<TObject, TKey>, IDisposable where TKey : notnull\\n\\n\\n// \\uC77D\\uAE30\\uC804\\uC6A9\\uC73C\\uB85C \\uB178\\uCD9C\\uB41C \\uC678\\uBD80\\uC5D0\\uC11C Connect()\\uD568\\uC73C\\uB85C\\uC368 \\n// change set\\uC744 \\uBC29\\uCD9C\\uD558\\uB294 observable\\uC744 \\uBC18\\uD658\\uD55C\\uB2E4.\\nIObservable<IChangeSet<Trede, long>> \\n    IConnectableCache<Trade, long>.Connect();\\n\")), mdx(\"h1\", null), mdx(\"h2\", null, \"3. Change Set Creation \\uC694\\uC57D\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// 1. FromObservable\\n`2\\uAC1C\\uC758 observables`\\uB97C \\uBC1B\\uC544 \\uD558\\uB098\\uC758 `IObservable<IChangeSet<T, TKey>>`\\uC744 \\uB9CC\\uB4E4\\uC5B4 \\uBC18\\uD658\\uD55C\\uB2E4.  \\n\\n// 2. FromTask\\nCreate an `observable change set` from a `Task`\\n\\n// 3. Reloadable\\n\\uC774\\uC804 data\\uB97C \\uC9C0\\uC6B0\\uACE0 \\uC0C8\\uB85C\\uC774 \\uB85C\\uB4DC\\uB41C data\\uB97C \\uCD94\\uAC00\\uD558\\uB294 \\uAE30\\uB2A5\\uC758 \\nDynamicData\\uC758 `Switch()` \\uC5F0\\uC0B0\\uC790\\uB97C \\uC0AC\\uC6A9\\uD558\\uC5EC \\uBC18\\uBCF5\\uC801\\uC73C\\uB85C data\\uB97C \\uB2E4\\uC2DC \\uB85C\\uB4DC\\uD55C\\uB2E4.\\n\\n// 4. Reloadable With EditDiff\\n\\uB178\\uC774\\uC988\\uB97C \\uD06C\\uAC8C \\uC904\\uC77C \\uC218 \\uC788\\uB294 `\\uBD88\\uD544\\uC694\\uD55C \\uC5C5\\uB370\\uC774\\uD2B8\\uB97C \\uC608\\uBC29`\\uD558\\uAE30 \\uC704\\uD574 \\n\\uC774\\uC804 \\uB85C\\uB4DC\\uC640\\uC758 diff set\\uB97C \\uACC4\\uC0B0\\uD558\\uB294 `ISourceCache<TObject, TKey>.EditDiff()`\\uB97C \\uC0AC\\uC6A9\\uD558\\uC5EC\\n\\uB2E4\\uC2DC \\uB85C\\uB4DC\\uD558\\uACE0 \\uBAA9\\uB85D\\uC744 \\uC720\\uC9C0\\uD55C\\uB2E4.\\n\\n// 5. FromTask With RefCount\\n\\uAD6C\\uB3C5\\uC774 \\uD558\\uB098 \\uC774\\uC0C1 \\uC788\\uB294 \\uD55C \\uC18C\\uC2A4\\uC5D0 \\uC5F0\\uACB0\\uB41C \\uC0C1\\uD0DC\\uB85C \\uC720\\uC9C0\\uB418\\uB294 \\uC2DC\\uD000\\uC2A4\\uB97C \\uBC18\\uD658\\uD55C\\uB2E4.  \\n\\uAD6C\\uB3C5\\uC774 0\\uC774\\uBA74 \\uC790\\uC2E0\\uC744 \\uD574\\uC9C0\\uD558\\uACE0 \\uB2E4\\uC2DC \\uC0C8\\uB85C\\uC6B4 \\uAD6C\\uB3C5\\uC774 \\uC624\\uBA74 \\uCC98\\uC74C\\uBD80\\uD130 \\uC790\\uB3D9\\uC73C\\uB85C \\uC2DC\\uC791\\uD55C\\uB2E4.\\n`RefCount()`\\uB294 `\\uD45C\\uC900 rx Publish().RefCount()` \\uC791\\uC5C5\\uC758 dd \\uC624\\uBC84\\uB85C\\uB4DC\\uC774\\uB2E4.\\ndd\\uAC00 \\uC790\\uB3D9\\uC73C\\uB85C \\uCC98\\uB9AC\\uD558\\uBBC0\\uB85C `Publish()`\\uB97C \\uC0AC\\uC6A9\\uD558\\uC9C0 \\uC54A\\uB294\\uB2E4.\\n\\n// 6. WithRetry\\n`Retry()` : In an enterprise app, would probably use a backoff retry strategy\\n\")), mdx(\"h1\", null), mdx(\"h2\", null, \"4. Inspect Collection \\uC694\\uC57D\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// 1. \\uC18C\\uC2A4\\uC758 \\uD56D\\uBAA9\\uC774 \\uCD94\\uAC00 \\uB418\\uAC70\\uB098 \\uC81C\\uAC70 \\uB420 \\uB54C \\uC804\\uCCB4 \\uCEEC\\uB809\\uC158\\uC744 \\uAC80\\uC0AC\\uD558\\uB294 \\uBC29\\uBC95.\\nObservableCacheEx.ToCollection();  \\n\\nthis.cleanUp = source\\n    .Connect()\\n    .ToCollection()  // \\uC18C\\uC2A4\\uAC00 \\uBCC0\\uACBD \\uB420 \\uB54C\\uB9C8\\uB2E4 \\uC0C8 \\uCEEC\\uB809\\uC158\\uC774 \\uC0DD\\uC131\\uB41C\\uB2E4.\\n\\n#\\n\\n// 2. TObject\\uC758 \\uC18D\\uC131\\uC774 \\uBCC0\\uACBD \\uB420 \\uB54C \\uC804\\uCCB4 \\uCEEC\\uB809\\uC158\\uC744 \\uAC80\\uC0AC\\uD558\\uB294 \\uBC29\\uBC95.\\nObservableCacheEx.AutoRefresh();\\n\\nthis.cleanUp = source\\n    .Connect()\\n    .AutoRefresh(vm => vm.IsActive)  // vm\\uC740 TObject, TObject.Property\\uAC00 \\uBCC0\\uACBD \\uB420 \\uB54C\\n    .ToCollection()  // \\uC18C\\uC2A4\\uC758 \\uD56D\\uBAA9\\uC778 TObject\\uAC00 \\uCD94\\uAC00\\uB418\\uAC70\\uB098 \\uC0AD\\uC81C \\uB420 \\uB54C\\n\\n#\\n\\n// 3. \\uC804\\uCCB4 \\uCEEC\\uB809\\uC158\\uC744 \\uAC80\\uC0AC\\uD558\\uACE0 \\n//    \\uB0B4\\uBD80 observables\\uC758 \\uD56D\\uBAA9\\uC774 \\uD65C\\uC131 \\uC0C1\\uD0DC\\uC778\\uC9C0 \\uC5EC\\uBD80\\uB97C \\uB300\\uC870\\uD558\\uB294 \\uBC29\\uBC95.\\nObservableCacheEx.MergeMany();\\nObservable.CombineLatest(); \\n\\nvar activeChanged = observableWithState\\n    .MergeMany(state => state.IsActive)  // IObservable<bool> IsActive\\n    // \\uD56D\\uBAA9\\uC774 \\uAE30\\uBCF8 \\uBAA9\\uB85D\\uC5D0 \\uCD94\\uAC00 \\uB420 \\uB54C observable\\uC744 \\uC790\\uB3D9\\uC73C\\uB85C \\uC5F0\\uACB0\\uD558\\uACE0 \\n    // \\uD56D\\uBAA9\\uC774 \\uC81C\\uAC70\\uB418\\uBA74 \\uC5F0\\uACB0\\uC744 \\uD574\\uC81C.\\n\\nvar collectionChanged = observableWithState.ToCollection();\\n// \\uAE30\\uBCF8 observable \\uBAA9\\uB85D\\uC774 \\uBCC0\\uACBD \\uB420 \\uB54C(\\uCD94\\uAC00, \\uC81C\\uAC70 \\uBC0F \\uAD50\\uCCB4) \\n// \\uC804\\uCCB4 \\uCEEC\\uB809\\uC158\\uC744 \\uACF5\\uAC1C(reveal)\\uD55C\\uB2E4.\\n\\ncollectionChanged\\n    .CombineLatest(activeChanged, (items, _) =>\\n    {\\n        // collectionChanged, activeChanged \\uC911 \\uD558\\uB098\\uAC00 \\uC694\\uC18C\\uB97C \\uC0DD\\uC131 \\uD560 \\uB54C\\uB9C8\\uB2E4 \\n        // \\uD638\\uCD9C\\uD558\\uB294 function.\\n        return items.Any() &&\\n        items.All(state => \\n        {\\n          state.LatestValue.HasValue && state.LatestValue == true;\\n        });\\n    });\\n\\n#\\n\\n// 4. \\uC120\\uD0DD\\uB41C \\uC544\\uC774\\uD15C\\uB4E4\\uC744 \\uBAA8\\uB2C8\\uD130\\uB9C1\\nObservableCacheEx.WhenPropertyChanged();  \\n// \\uCEEC\\uB809\\uC158\\uC758 \\uAC01 \\uD56D\\uBAA9\\uC744 \\uBCF4\\uACE0 \\uBCC0\\uACBD\\uB41C \\uD56D\\uBAA9\\uC774 \\uC788\\uC73C\\uBA74 \\uC54C\\uB9B0\\uB2E4.\\n\\nvar selectedItems = this.source\\n    .Connect()\\n    .AutoRefresh(si => si.IsSelected)\\n    .Filter(si => si.IsSelected)\\n    .ToCollection()\\n    .StartWithEmpty()\\n    .Publish();\\n\\n// \\uAE30\\uBCF8 \\uBAA9\\uB85D\\uC774 \\uBCC0\\uACBD\\uB418\\uAC70\\uB098 IsSelected\\uAC00 \\uBCC0\\uACBD \\uB420 \\uB54C \\uAD00\\uCC30 \\uAC00\\uB2A5 \\uD56D\\uBAA9\\uC744 \\uC0DD\\uC131.\\nvar shared = this.source.Connect().Publish();\\nvar selectedChanged = shared\\n    .WhenPropertyChanged(si => si.IsSelected)\\n    .Select(_ => Unit.Default)\\n    .StartWith(Unit.Default);\\nvar collectionChanged = shared\\n    .ToCollection()\\n    .CombineLatest(selectedChanged, (items, _) => items)\\n    .Publish();\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}}},"staticQueryHashes":[]}